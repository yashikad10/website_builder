/// <reference types="node" />
import { StacksTransaction } from './transaction';
import { StacksNetwork } from './network';
import { PostCondition, STXPostCondition, FungiblePostCondition, NonFungiblePostCondition } from './postcondition';
import { AddressHashMode, FungibleConditionCode, NonFungibleConditionCode, PostConditionMode, AnchorMode, TxRejectedReason } from './constants';
import { AssetInfo } from './types';
import * as BigNum from 'bn.js';
import { ClarityValue, PrincipalCV } from './clarity';
import { ClarityAbi } from './contract-abi';
/**
 * Lookup the nonce for an address from a core node
 *
 * @param {string} address - the c32check address to look up
 * @param {StacksNetwork} network - the Stacks network to look up address on
 *
 * @return a promise that resolves to an integer
 */
export declare function getNonce(address: string, network?: StacksNetwork): Promise<BigNum>;
/**
 * Estimate the total transaction fee in microstacks for a token transfer
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for
 * @param {StacksNetwork} network - the Stacks network to estimate transaction for
 *
 * @return a promise that resolves to number of microstacks per byte
 */
export declare function estimateTransfer(transaction: StacksTransaction, network?: StacksNetwork): Promise<BigNum>;
export declare type TxBroadcastResultOk = string;
export declare type TxBroadcastResultRejected = {
    error: string;
    reason: TxRejectedReason;
    reason_data: any;
    txid: string;
};
export declare type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;
/**
 * Broadcast the signed transaction to a core node
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to broadcast
 * @param {StacksNetwork} network - the Stacks network to broadcast transaction to
 *
 * @returns {Promise} that resolves to a response if the operation succeeds
 */
export declare function broadcastTransaction(transaction: StacksTransaction, network: StacksNetwork): Promise<TxBroadcastResult>;
/**
 * Broadcast the signed transaction to a core node
 *
 * @param {Buffer} rawTx - the raw serialized transaction buffer to broadcast
 * @param {string} url - the broadcast endpoint URL
 *
 * @returns {Promise} that resolves to a response if the operation succeeds
 */
export declare function broadcastRawTransaction(rawTx: Buffer, url: string): Promise<TxBroadcastResult>;
/**
 * Fetch a contract's ABI
 *
 * @param {string} address - the contracts address
 * @param {string} contractName - the contracts name
 * @param {StacksNetwork} network - the Stacks network to broadcast transaction to
 *
 * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds
 */
export declare function getAbi(address: string, contractName: string, network: StacksNetwork): Promise<ClarityAbi>;
export interface MultiSigOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys?: string[];
}
/**
 * STX token transfer transaction options
 *
 * @param  {String|PrincipalCV} recipientAddress - the c32check address of the recipient or a
 *                                                  principal clarity value
 * @param  {BigNum} amount - number of tokens to transfer in microstacks
 * @param  {BigNum} fee - transaction fee in microstacks
 * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction
 * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for
 * @param  {anchorMode} anchorMode - identify how the the transaction should be mined
 * @param  {String} memo - an arbitrary string to include with the transaction, must be less than
 *                          34 bytes
 * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all
 *                                                 transferred assets
 * @param  {PostCondition[]} postConditions - an array of post conditions to add to the
 *                                                  transaction
 * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees
 */
export interface TokenTransferOptions {
    recipient: string | PrincipalCV;
    amount: BigNum;
    fee?: BigNum;
    nonce?: BigNum;
    network?: StacksNetwork;
    anchorMode?: AnchorMode;
    memo?: string;
    postConditionMode?: PostConditionMode;
    postConditions?: PostCondition[];
    sponsored?: boolean;
}
export interface UnsignedTokenTransferOptions extends TokenTransferOptions {
    publicKey: string;
}
export interface SignedTokenTransferOptions extends TokenTransferOptions {
    senderKey: string;
}
export interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {
    numSignatures: number;
    publicKeys: string[];
}
export interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys: string[];
}
/**
 * Generates an unsigned Stacks token transfer transaction
 *
 * Returns a Stacks token transfer transaction.
 *
 * @param  {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer
 *
 * @return {StacksTransaction}
 */
export declare function makeUnsignedSTXTokenTransfer(txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions): Promise<StacksTransaction>;
/**
 * Generates a signed Stacks token transfer transaction
 *
 * Returns a signed Stacks token transfer transaction.
 *
 * @param  {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer
 *
 * @return {StacksTransaction}
 */
export declare function makeSTXTokenTransfer(txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions): Promise<StacksTransaction>;
/**
 * Contract deploy transaction options
 *
 * @param  {String} contractName - the contract name
 * @param  {String} codeBody - the code body string
 * @param  {String} senderKey - hex string sender private key used to sign transaction
 * @param  {BigNum} fee - transaction fee in microstacks
 * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction
 * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for
 * @param  {anchorMode} anchorMode - identify how the the transaction should be mined
 * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all
 *                                                 transferred assets
 * @param  {PostCondition[]} postConditions - an array of post conditions to add to the
 *                                                  transaction
 * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees
 */
export interface ContractDeployOptions {
    contractName: string;
    codeBody: string;
    senderKey: string;
    fee?: BigNum;
    nonce?: BigNum;
    network?: StacksNetwork;
    anchorMode?: AnchorMode;
    postConditionMode?: PostConditionMode;
    postConditions?: PostCondition[];
    sponsored?: boolean;
}
/**
 * Estimate the total transaction fee in microstacks for a contract deploy
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for
 * @param {StacksNetwork} network - the Stacks network to estimate transaction for
 *
 * @return a promise that resolves to number of microstacks per byte
 */
export declare function estimateContractDeploy(transaction: StacksTransaction, network?: StacksNetwork): Promise<BigNum>;
/**
 * Generates a Clarity smart contract deploy transaction
 *
 * @param  {ContractDeployOptions} txOptions - an options object for the contract deploy
 *
 * Returns a signed Stacks smart contract deploy transaction.
 *
 * @return {StacksTransaction}
 */
export declare function makeContractDeploy(txOptions: ContractDeployOptions): Promise<StacksTransaction>;
/**
 * Contract function call transaction options
 * @param  {String} contractAddress - the c32check address of the contract
 * @param  {String} contractName - the contract name
 * @param  {String} functionName - name of the function to be called
 * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call
 * @param  {String} senderKey - hex string sender private key used to sign transaction
 * @param  {BigNum} fee - transaction fee in microstacks
 * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction
 * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for
 * @param  {anchorMode} anchorMode - identify how the the transaction should be mined
 * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all
 *                                                 transferred assets
 * @param  {PostCondition[]} postConditions - an array of post conditions to add to the
 *                                                  transaction
 * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees
 */
export interface ContractCallOptions {
    contractAddress: string;
    contractName: string;
    functionName: string;
    functionArgs: ClarityValue[];
    senderKey: string;
    fee?: BigNum;
    feeEstimateApiUrl?: string;
    nonce?: BigNum;
    network?: StacksNetwork;
    anchorMode?: AnchorMode;
    postConditionMode?: PostConditionMode;
    postConditions?: PostCondition[];
    validateWithAbi?: boolean | ClarityAbi;
    sponsored?: boolean;
}
/**
 * Estimate the total transaction fee in microstacks for a contract function call
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for
 * @param {StacksNetwork} network - the Stacks network to estimate transaction for
 *
 * @return a promise that resolves to number of microstacks per byte
 */
export declare function estimateContractFunctionCall(transaction: StacksTransaction, network?: StacksNetwork): Promise<BigNum>;
/**
 * Generates a Clarity smart contract function call transaction
 *
 * @param  {ContractCallOptions} txOptions - an options object for the contract function call
 *
 * Returns a signed Stacks smart contract function call transaction.
 *
 * @return {StacksTransaction}
 */
export declare function makeContractCall(txOptions: ContractCallOptions): Promise<StacksTransaction>;
/**
 * Generates a STX post condition with a standard principal
 *
 * Returns a STX post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of STX tokens
 *
 * @return {STXPostCondition}
 */
export declare function makeStandardSTXPostCondition(address: string, conditionCode: FungibleConditionCode, amount: BigNum): STXPostCondition;
/**
 * Generates a STX post condition with a contract principal
 *
 * Returns a STX post condition object
 *
 * @param  {String} address - the c32check address of the contract
 * @param  {String} contractName - the name of the contract
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of STX tokens
 *
 * @return {STXPostCondition}
 */
export declare function makeContractSTXPostCondition(address: string, contractName: string, conditionCode: FungibleConditionCode, amount: BigNum): STXPostCondition;
/**
 * Generates a fungible token post condition with a standard principal
 *
 * Returns a fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of fungible tokens
 * @param  {AssetInfo} assetInfo - asset info describing the fungible token
 *
 * @return {FungiblePostCondition}
 */
export declare function makeStandardFungiblePostCondition(address: string, conditionCode: FungibleConditionCode, amount: BigNum, assetInfo: string | AssetInfo): FungiblePostCondition;
/**
 * Generates a fungible token post condition with a contract principal
 *
 * Returns a fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {String} contractName - the name of the contract
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of fungible tokens
 * @param  {AssetInfo} assetInfo - asset info describing the fungible token
 *
 * @return {FungiblePostCondition}
 */
export declare function makeContractFungiblePostCondition(address: string, contractName: string, conditionCode: FungibleConditionCode, amount: BigNum, assetInfo: string | AssetInfo): FungiblePostCondition;
/**
 * Generates a non-fungible token post condition with a standard principal
 *
 * Returns a non-fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token
 * @param  {ClarityValue} assetName - asset name describing the non-fungible token
 *
 * @return {NonFungiblePostCondition}
 */
export declare function makeStandardNonFungiblePostCondition(address: string, conditionCode: NonFungibleConditionCode, assetInfo: string | AssetInfo, assetName: ClarityValue): NonFungiblePostCondition;
/**
 * Generates a non-fungible token post condition with a contract principal
 *
 * Returns a non-fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {String} contractName - the name of the contract
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token
 * @param  {ClarityValue} assetName - asset name describing the non-fungible token
 *
 * @return {NonFungiblePostCondition}
 */
export declare function makeContractNonFungiblePostCondition(address: string, contractName: string, conditionCode: NonFungibleConditionCode, assetInfo: string | AssetInfo, assetName: ClarityValue): NonFungiblePostCondition;
/**
 * Read only function options
 *
 * @param  {String} contractAddress - the c32check address of the contract
 * @param  {String} contractName - the contract name
 * @param  {String} functionName - name of the function to be called
 * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call
 * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for
 * @param  {String} senderAddress - the c32check address of the sender
 */
export interface ReadOnlyFunctionOptions {
    contractName: string;
    contractAddress: string;
    functionName: string;
    functionArgs: ClarityValue[];
    network?: StacksNetwork;
    senderAddress: string;
}
/**
 * Calls a read only function from a contract interface
 *
 * @param  {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object
 *
 * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.
 *
 * @return {ClarityValue}
 */
export declare function callReadOnlyFunction(readOnlyFunctionOptions: ReadOnlyFunctionOptions): Promise<ClarityValue>;
/**
 * Sponsored transaction options
 *
 * @param  {StacksTransaction} transaction - the origin-signed transaction to sponsor
 * @param  {String} sponsorPrivateKey - the sponsor's private key
 * @param  {BigNum} fee - the transaction fee amount to sponsor
 * @param  {BigNum} sponsorNonce - the nonce of the sponsor account
 * @param  {AddressHashMode} sponsorAddressHashmode - the sponsor address hashmode
 * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for
 */
export interface SponsorOptions {
    transaction: StacksTransaction;
    sponsorPrivateKey: string;
    fee?: BigNum;
    sponsorNonce?: BigNum;
    sponsorAddressHashmode?: AddressHashMode;
    network?: StacksNetwork;
}
/**
 * Constructs and signs a sponsored transaction as the sponsor
 *
 * @param  {SponsorOptions} sponsorOptions - the sponsor options object
 *
 * Returns a signed sponsored transaction.
 *
 * @return {ClarityValue}
 */
export declare function sponsorTransaction(sponsorOptions: SponsorOptions): Promise<StacksTransaction>;
