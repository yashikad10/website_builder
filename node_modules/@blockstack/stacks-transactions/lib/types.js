"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeLPList = exports.serializeLPList = exports.createLPList = exports.deserializeAssetInfo = exports.serializeAssetInfo = exports.createAssetInfo = exports.parseAssetInfoString = exports.deserializeMemoString = exports.serializeMemoString = exports.createMemoString = exports.codeBodyString = exports.deserializeLPString = exports.serializeLPString = exports.createLPString = exports.deserializePrincipal = exports.serializePrincipal = exports.createContractPrincipal = exports.createStandardPrincipal = exports.parsePrincipalString = exports.deserializeAddress = exports.serializeAddress = exports.addressToString = exports.addressFromPublicKeys = exports.addressFromHashMode = exports.addressHashModeToVersion = exports.addressFromVersionHash = exports.createEmptyAddress = exports.createAddress = exports.deserializeStacksMessage = exports.serializeStacksMessage = void 0;
const constants_1 = require("./constants");
const keys_1 = require("./keys");
const utils_1 = require("./utils");
const c32check_1 = require("c32check");
const postcondition_1 = require("./postcondition");
const payload_1 = require("./payload");
const errors_1 = require("./errors");
const authorization_1 = require("./authorization");
function serializeStacksMessage(message) {
    switch (message.type) {
        case constants_1.StacksMessageType.Address:
            return serializeAddress(message);
        case constants_1.StacksMessageType.Principal:
            return serializePrincipal(message);
        case constants_1.StacksMessageType.LengthPrefixedString:
            return serializeLPString(message);
        case constants_1.StacksMessageType.MemoString:
            return serializeMemoString(message);
        case constants_1.StacksMessageType.AssetInfo:
            return serializeAssetInfo(message);
        case constants_1.StacksMessageType.PostCondition:
            return postcondition_1.serializePostCondition(message);
        case constants_1.StacksMessageType.PublicKey:
            return keys_1.serializePublicKey(message);
        case constants_1.StacksMessageType.LengthPrefixedList:
            return serializeLPList(message);
        case constants_1.StacksMessageType.Payload:
            return payload_1.serializePayload(message);
        case constants_1.StacksMessageType.TransactionAuthField:
            return authorization_1.serializeTransactionAuthField(message);
        case constants_1.StacksMessageType.MessageSignature:
            return authorization_1.serializeMessageSignature(message);
    }
}
exports.serializeStacksMessage = serializeStacksMessage;
function deserializeStacksMessage(bufferReader, type, listType) {
    switch (type) {
        case constants_1.StacksMessageType.Address:
            return deserializeAddress(bufferReader);
        case constants_1.StacksMessageType.Principal:
            return deserializePrincipal(bufferReader);
        case constants_1.StacksMessageType.LengthPrefixedString:
            return deserializeLPString(bufferReader);
        case constants_1.StacksMessageType.MemoString:
            return deserializeMemoString(bufferReader);
        case constants_1.StacksMessageType.AssetInfo:
            return deserializeAssetInfo(bufferReader);
        case constants_1.StacksMessageType.PostCondition:
            return postcondition_1.deserializePostCondition(bufferReader);
        case constants_1.StacksMessageType.PublicKey:
            return keys_1.deserializePublicKey(bufferReader);
        case constants_1.StacksMessageType.Payload:
            return payload_1.deserializePayload(bufferReader);
        case constants_1.StacksMessageType.LengthPrefixedList:
            if (!listType) {
                throw new errors_1.DeserializationError('No List Type specified');
            }
            return deserializeLPList(bufferReader, listType);
        case constants_1.StacksMessageType.MessageSignature:
            return authorization_1.deserializeMessageSignature(bufferReader);
        default:
            throw new Error('Could not recognize StacksMessageType');
    }
}
exports.deserializeStacksMessage = deserializeStacksMessage;
function createAddress(c32AddressString) {
    const addressData = c32check_1.c32addressDecode(c32AddressString);
    return {
        type: constants_1.StacksMessageType.Address,
        version: addressData[0],
        hash160: addressData[1],
    };
}
exports.createAddress = createAddress;
function createEmptyAddress() {
    return {
        type: constants_1.StacksMessageType.Address,
        version: constants_1.AddressVersion.MainnetSingleSig,
        hash160: '0'.repeat(40),
    };
}
exports.createEmptyAddress = createEmptyAddress;
function addressFromVersionHash(version, hash) {
    return { type: constants_1.StacksMessageType.Address, version, hash160: hash };
}
exports.addressFromVersionHash = addressFromVersionHash;
/**
 * Translates the tx auth hash mode to the corresponding address version.
 * @see https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#transaction-authorization
 */
function addressHashModeToVersion(hashMode, txVersion) {
    switch (hashMode) {
        case constants_1.AddressHashMode.SerializeP2PKH:
            switch (txVersion) {
                case constants_1.TransactionVersion.Mainnet:
                    return constants_1.AddressVersion.MainnetSingleSig;
                case constants_1.TransactionVersion.Testnet:
                    return constants_1.AddressVersion.TestnetSingleSig;
                default:
                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
            }
        case constants_1.AddressHashMode.SerializeP2SH:
        case constants_1.AddressHashMode.SerializeP2WPKH:
        case constants_1.AddressHashMode.SerializeP2WSH:
            switch (txVersion) {
                case constants_1.TransactionVersion.Mainnet:
                    return constants_1.AddressVersion.MainnetMultiSig;
                case constants_1.TransactionVersion.Testnet:
                    return constants_1.AddressVersion.TestnetMultiSig;
                default:
                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
            }
        default:
            throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);
    }
}
exports.addressHashModeToVersion = addressHashModeToVersion;
function addressFromHashMode(hashMode, txVersion, data) {
    const version = addressHashModeToVersion(hashMode, txVersion);
    return addressFromVersionHash(version, data);
}
exports.addressFromHashMode = addressFromHashMode;
function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {
    if (publicKeys.length === 0) {
        throw Error('Invalid number of public keys');
    }
    if (hashMode === constants_1.AddressHashMode.SerializeP2PKH || hashMode === constants_1.AddressHashMode.SerializeP2WPKH) {
        if (publicKeys.length !== 1 || numSigs !== 1) {
            throw Error('Invalid number of public keys or signatures');
        }
    }
    if (hashMode === constants_1.AddressHashMode.SerializeP2WPKH || hashMode === constants_1.AddressHashMode.SerializeP2WSH) {
        for (let i = 0; i < publicKeys.length; i++) {
            if (!keys_1.isCompressed(publicKeys[i])) {
                throw Error('Public keys must be compressed for segwit');
            }
        }
    }
    switch (hashMode) {
        case constants_1.AddressHashMode.SerializeP2PKH:
            return addressFromVersionHash(version, utils_1.hashP2PKH(publicKeys[0].data));
        case constants_1.AddressHashMode.SerializeP2SH:
            return addressFromVersionHash(version, utils_1.hashP2SH(numSigs, publicKeys.map(keys_1.serializePublicKey)));
        default:
            throw Error(`Not yet implemented: address construction using public keys for hash mode: ${hashMode}`);
    }
}
exports.addressFromPublicKeys = addressFromPublicKeys;
function addressToString(address) {
    return c32check_1.c32address(address.version, address.hash160).toString();
}
exports.addressToString = addressToString;
function serializeAddress(address) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendHexString(utils_1.intToHexString(address.version, 1));
    bufferArray.appendHexString(address.hash160);
    return bufferArray.concatBuffer();
}
exports.serializeAddress = serializeAddress;
function deserializeAddress(bufferReader) {
    const version = utils_1.hexStringToInt(bufferReader.readBuffer(1).toString('hex'));
    const data = bufferReader.readBuffer(20).toString('hex');
    return { type: constants_1.StacksMessageType.Address, version, hash160: data };
}
exports.deserializeAddress = deserializeAddress;
/**
 * Parses a principal string for either a standard principal or contract principal.
 * @param principalString - String in the format `{address}.{contractName}`
 * @example "SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract"
 * @example "SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G"
 */
function parsePrincipalString(principalString) {
    if (principalString.includes('.')) {
        const [address, contractName] = principalString.split('.');
        return createContractPrincipal(address, contractName);
    }
    else {
        return createStandardPrincipal(principalString);
    }
}
exports.parsePrincipalString = parsePrincipalString;
function createStandardPrincipal(addressString) {
    const addr = createAddress(addressString);
    return {
        type: constants_1.StacksMessageType.Principal,
        prefix: constants_1.PostConditionPrincipalID.Standard,
        address: addr,
    };
}
exports.createStandardPrincipal = createStandardPrincipal;
function createContractPrincipal(addressString, contractName) {
    const addr = createAddress(addressString);
    const name = createLPString(contractName);
    return {
        type: constants_1.StacksMessageType.Principal,
        prefix: constants_1.PostConditionPrincipalID.Contract,
        address: addr,
        contractName: name,
    };
}
exports.createContractPrincipal = createContractPrincipal;
function serializePrincipal(principal) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.push(Buffer.from([principal.prefix]));
    bufferArray.push(serializeAddress(principal.address));
    if (principal.prefix === constants_1.PostConditionPrincipalID.Contract) {
        bufferArray.push(serializeLPString(principal.contractName));
    }
    return bufferArray.concatBuffer();
}
exports.serializePrincipal = serializePrincipal;
function deserializePrincipal(bufferReader) {
    const prefix = bufferReader.readUInt8Enum(constants_1.PostConditionPrincipalID, n => {
        throw new errors_1.DeserializationError('Unexpected Principal payload type: ${n}');
    });
    const address = deserializeAddress(bufferReader);
    if (prefix === constants_1.PostConditionPrincipalID.Standard) {
        return { type: constants_1.StacksMessageType.Principal, prefix, address };
    }
    const contractName = deserializeLPString(bufferReader);
    return {
        type: constants_1.StacksMessageType.Principal,
        prefix,
        address,
        contractName,
    };
}
exports.deserializePrincipal = deserializePrincipal;
function createLPString(content, lengthPrefixBytes, maxLengthBytes) {
    const prefixLength = lengthPrefixBytes || 1;
    const maxLength = maxLengthBytes || constants_1.MAX_STRING_LENGTH_BYTES;
    if (utils_1.exceedsMaxLengthBytes(content, maxLength)) {
        throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);
    }
    return {
        type: constants_1.StacksMessageType.LengthPrefixedString,
        content,
        lengthPrefixBytes: prefixLength,
        maxLengthBytes: maxLength,
    };
}
exports.createLPString = createLPString;
function serializeLPString(lps) {
    const bufferArray = new utils_1.BufferArray();
    const contentBuffer = Buffer.from(lps.content);
    const length = contentBuffer.byteLength;
    bufferArray.appendHexString(utils_1.intToHexString(length, lps.lengthPrefixBytes));
    bufferArray.push(contentBuffer);
    return bufferArray.concatBuffer();
}
exports.serializeLPString = serializeLPString;
function deserializeLPString(bufferReader, prefixBytes, maxLength) {
    prefixBytes = prefixBytes ? prefixBytes : 1;
    const length = utils_1.hexStringToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));
    const content = bufferReader.readBuffer(length).toString();
    return createLPString(content, prefixBytes, maxLength !== null && maxLength !== void 0 ? maxLength : 128);
}
exports.deserializeLPString = deserializeLPString;
function codeBodyString(content) {
    return createLPString(content, 4, 100000);
}
exports.codeBodyString = codeBodyString;
function createMemoString(content) {
    if (content && utils_1.exceedsMaxLengthBytes(content, constants_1.MEMO_MAX_LENGTH_BYTES)) {
        throw new Error(`Memo exceeds maximum length of ${constants_1.MEMO_MAX_LENGTH_BYTES.toString()} bytes`);
    }
    return { type: constants_1.StacksMessageType.MemoString, content };
}
exports.createMemoString = createMemoString;
function serializeMemoString(memoString) {
    const bufferArray = new utils_1.BufferArray();
    const contentBuffer = Buffer.from(memoString.content);
    const paddedContent = utils_1.rightPadHexToLength(contentBuffer.toString('hex'), constants_1.MEMO_MAX_LENGTH_BYTES * 2);
    bufferArray.push(Buffer.from(paddedContent, 'hex'));
    return bufferArray.concatBuffer();
}
exports.serializeMemoString = serializeMemoString;
function deserializeMemoString(bufferReader) {
    const content = bufferReader.readBuffer(constants_1.MEMO_MAX_LENGTH_BYTES).toString();
    return { type: constants_1.StacksMessageType.MemoString, content };
}
exports.deserializeMemoString = deserializeMemoString;
/**
 * Parse a fully qualified string that identifies the token type.
 * @param id - String in the format `{address}.{contractName}::{assetName}`
 * @example "SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract::example-token"
 */
function parseAssetInfoString(id) {
    const [assetAddress, assetContractName, assetTokenName] = id.split(/\.|::/);
    const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);
    return assetInfo;
}
exports.parseAssetInfoString = parseAssetInfoString;
function createAssetInfo(addressString, contractName, assetName) {
    return {
        type: constants_1.StacksMessageType.AssetInfo,
        address: createAddress(addressString),
        contractName: createLPString(contractName),
        assetName: createLPString(assetName),
    };
}
exports.createAssetInfo = createAssetInfo;
function serializeAssetInfo(info) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.push(serializeAddress(info.address));
    bufferArray.push(serializeLPString(info.contractName));
    bufferArray.push(serializeLPString(info.assetName));
    return bufferArray.concatBuffer();
}
exports.serializeAssetInfo = serializeAssetInfo;
function deserializeAssetInfo(bufferReader) {
    return {
        type: constants_1.StacksMessageType.AssetInfo,
        address: deserializeAddress(bufferReader),
        contractName: deserializeLPString(bufferReader),
        assetName: deserializeLPString(bufferReader),
    };
}
exports.deserializeAssetInfo = deserializeAssetInfo;
function createLPList(values, lengthPrefixBytes) {
    return {
        type: constants_1.StacksMessageType.LengthPrefixedList,
        lengthPrefixBytes: lengthPrefixBytes || 4,
        values,
    };
}
exports.createLPList = createLPList;
function serializeLPList(lpList) {
    const list = lpList.values;
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendHexString(utils_1.intToHexString(list.length, lpList.lengthPrefixBytes));
    for (let index = 0; index < list.length; index++) {
        bufferArray.push(serializeStacksMessage(list[index]));
    }
    return bufferArray.concatBuffer();
}
exports.serializeLPList = serializeLPList;
function deserializeLPList(bufferReader, type, lengthPrefixBytes) {
    const length = utils_1.hexStringToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));
    const l = [];
    for (let index = 0; index < length; index++) {
        switch (type) {
            case constants_1.StacksMessageType.Address:
                l.push(deserializeAddress(bufferReader));
                break;
            case constants_1.StacksMessageType.LengthPrefixedString:
                l.push(deserializeLPString(bufferReader));
                break;
            case constants_1.StacksMessageType.MemoString:
                l.push(deserializeMemoString(bufferReader));
                break;
            case constants_1.StacksMessageType.AssetInfo:
                l.push(deserializeAssetInfo(bufferReader));
                break;
            case constants_1.StacksMessageType.PostCondition:
                l.push(postcondition_1.deserializePostCondition(bufferReader));
                break;
            case constants_1.StacksMessageType.PublicKey:
                l.push(keys_1.deserializePublicKey(bufferReader));
                break;
            case constants_1.StacksMessageType.TransactionAuthField:
                l.push(authorization_1.deserializeTransactionAuthField(bufferReader));
                break;
        }
    }
    return createLPList(l, lengthPrefixBytes);
}
exports.deserializeLPList = deserializeLPList;
//# sourceMappingURL=types.js.map