"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SponsoredAuthorization = exports.StandardAuthorization = exports.Authorization = exports.nextVerification = exports.nextSignature = exports.makeSigHashPreSign = exports.deserializeSpendingCondition = exports.serializeSpendingCondition = exports.deserializeMultiSigSpendingCondition = exports.deserializeSingleSigSpendingCondition = exports.serializeMultiSigSpendingCondition = exports.serializeSingleSigSpendingCondition = exports.isSingleSig = exports.createMultiSigSpendingCondition = exports.createSingleSigSpendingCondition = exports.deserializeTransactionAuthField = exports.serializeTransactionAuthField = exports.createTransactionAuthField = exports.deserializeMessageSignature = exports.serializeMessageSignature = exports.emptyMessageSignature = exports.createMessageSignature = void 0;
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const types_1 = require("./types");
const keys_1 = require("./keys");
const BigNum = require("bn.js");
const errors_1 = require("./errors");
class Deserializable {
    static deserialize(bufferReader) {
        const message = new this();
        message.deserialize(bufferReader);
        return message;
    }
}
function createMessageSignature(signature) {
    const length = Buffer.from(signature, 'hex').byteLength;
    if (length != constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {
        throw Error('Invalid signature');
    }
    return {
        type: constants_1.StacksMessageType.MessageSignature,
        data: signature,
    };
}
exports.createMessageSignature = createMessageSignature;
function emptyMessageSignature() {
    return {
        type: constants_1.StacksMessageType.MessageSignature,
        data: Buffer.alloc(constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex'),
    };
}
exports.emptyMessageSignature = emptyMessageSignature;
function serializeMessageSignature(messageSignature) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendHexString(messageSignature.data);
    return bufferArray.concatBuffer();
}
exports.serializeMessageSignature = serializeMessageSignature;
function deserializeMessageSignature(bufferReader) {
    return createMessageSignature(bufferReader.readBuffer(constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));
}
exports.deserializeMessageSignature = deserializeMessageSignature;
var AuthFieldType;
(function (AuthFieldType) {
    AuthFieldType[AuthFieldType["PublicKey"] = 0] = "PublicKey";
    AuthFieldType[AuthFieldType["Signature"] = 2] = "Signature";
})(AuthFieldType || (AuthFieldType = {}));
function createTransactionAuthField(contents) {
    return {
        type: constants_1.StacksMessageType.TransactionAuthField,
        contents,
    };
}
exports.createTransactionAuthField = createTransactionAuthField;
function serializeTransactionAuthField(field) {
    const bufferArray = new utils_1.BufferArray();
    switch (field.contents.type) {
        case constants_1.StacksMessageType.PublicKey:
            bufferArray.appendByte(AuthFieldType.PublicKey);
            bufferArray.push(keys_1.serializePublicKey(field.contents));
            break;
        case constants_1.StacksMessageType.MessageSignature:
            bufferArray.appendByte(AuthFieldType.Signature);
            bufferArray.push(serializeMessageSignature(field.contents));
            break;
    }
    return bufferArray.concatBuffer();
}
exports.serializeTransactionAuthField = serializeTransactionAuthField;
function deserializeTransactionAuthField(bufferReader) {
    const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {
        throw new errors_1.DeserializationError(`Could not read ${n} as AuthFieldType`);
    });
    switch (authFieldType) {
        case AuthFieldType.PublicKey:
            return createTransactionAuthField(keys_1.deserializePublicKey(bufferReader));
        case AuthFieldType.Signature:
            return createTransactionAuthField(deserializeMessageSignature(bufferReader));
        default:
            throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);
    }
}
exports.deserializeTransactionAuthField = deserializeTransactionAuthField;
function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {
    // address version arg doesn't matter for signer hash generation
    const signer = types_1.addressFromPublicKeys(0, hashMode, 1, [keys_1.createStacksPublicKey(pubKey)]).hash160;
    const keyEncoding = keys_1.isCompressed(keys_1.createStacksPublicKey(pubKey))
        ? constants_1.PubKeyEncoding.Compressed
        : constants_1.PubKeyEncoding.Uncompressed;
    return {
        hashMode,
        signer,
        nonce,
        fee,
        keyEncoding,
        signature: emptyMessageSignature(),
    };
}
exports.createSingleSigSpendingCondition = createSingleSigSpendingCondition;
function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {
    const stacksPublicKeys = pubKeys.map(keys_1.createStacksPublicKey);
    // address version arg doesn't matter for signer hash generation
    const signer = types_1.addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;
    return {
        hashMode,
        signer,
        nonce,
        fee,
        fields: [],
        signaturesRequired: numSigs,
    };
}
exports.createMultiSigSpendingCondition = createMultiSigSpendingCondition;
function isSingleSig(condition) {
    return 'signature' in condition;
}
exports.isSingleSig = isSingleSig;
function clearCondition(condition) {
    const cloned = utils_1.cloneDeep(condition);
    cloned.nonce = new BigNum(0);
    cloned.fee = new BigNum(0);
    if (isSingleSig(cloned)) {
        cloned.signature = emptyMessageSignature();
    }
    else {
        cloned.fields = [];
    }
    return cloned;
}
function serializeSingleSigSpendingCondition(condition) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendByte(condition.hashMode);
    bufferArray.appendHexString(condition.signer);
    bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));
    bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));
    bufferArray.appendByte(condition.keyEncoding);
    bufferArray.push(serializeMessageSignature(condition.signature));
    return bufferArray.concatBuffer();
}
exports.serializeSingleSigSpendingCondition = serializeSingleSigSpendingCondition;
function serializeMultiSigSpendingCondition(condition) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendByte(condition.hashMode);
    bufferArray.appendHexString(condition.signer);
    bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));
    bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));
    const fields = types_1.createLPList(condition.fields);
    bufferArray.push(types_1.serializeLPList(fields));
    const numSigs = Buffer.alloc(2);
    numSigs.writeUInt16BE(condition.signaturesRequired, 0);
    bufferArray.push(numSigs);
    return bufferArray.concatBuffer();
}
exports.serializeMultiSigSpendingCondition = serializeMultiSigSpendingCondition;
function deserializeSingleSigSpendingCondition(hashMode, bufferReader) {
    const signer = bufferReader.readBuffer(20).toString('hex');
    const nonce = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
    const fee = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
    const keyEncoding = bufferReader.readUInt8Enum(constants_1.PubKeyEncoding, n => {
        throw new errors_1.DeserializationError(`Could not parse ${n} as PubKeyEncoding`);
    });
    const signature = deserializeMessageSignature(bufferReader);
    return {
        hashMode,
        signer,
        nonce,
        fee,
        keyEncoding,
        signature,
    };
}
exports.deserializeSingleSigSpendingCondition = deserializeSingleSigSpendingCondition;
function deserializeMultiSigSpendingCondition(hashMode, bufferReader) {
    const signer = bufferReader.readBuffer(20).toString('hex');
    const nonce = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
    const fee = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
    const fields = types_1.deserializeLPList(bufferReader, constants_1.StacksMessageType.TransactionAuthField)
        .values;
    const signaturesRequired = bufferReader.readUInt16BE();
    return {
        hashMode,
        signer,
        nonce,
        fee,
        fields,
        signaturesRequired,
    };
}
exports.deserializeMultiSigSpendingCondition = deserializeMultiSigSpendingCondition;
function serializeSpendingCondition(condition) {
    if (isSingleSig(condition)) {
        return serializeSingleSigSpendingCondition(condition);
    }
    else {
        return serializeMultiSigSpendingCondition(condition);
    }
}
exports.serializeSpendingCondition = serializeSpendingCondition;
function deserializeSpendingCondition(bufferReader) {
    const hashMode = bufferReader.readUInt8Enum(constants_1.AddressHashMode, n => {
        throw new errors_1.DeserializationError(`Could not parse ${n} as AddressHashMode`);
    });
    if (hashMode === constants_1.AddressHashMode.SerializeP2PKH || hashMode === constants_1.AddressHashMode.SerializeP2WPKH) {
        return deserializeSingleSigSpendingCondition(hashMode, bufferReader);
    }
    else {
        return deserializeMultiSigSpendingCondition(hashMode, bufferReader);
    }
}
exports.deserializeSpendingCondition = deserializeSpendingCondition;
function makeSigHashPreSign(curSigHash, authType, fee, nonce) {
    // new hash combines the previous hash and all the new data this signature will add. This
    // includes:
    // * the previous hash
    // * the auth flag
    // * the tx fee (big-endian 8-byte number)
    // * nonce (big-endian 8-byte number)
    const hashLength = 32 + 1 + 8 + 8;
    const sigHash = curSigHash +
        Buffer.from([authType]).toString('hex') +
        fee.toArrayLike(Buffer, 'be', 8).toString('hex') +
        nonce.toArrayLike(Buffer, 'be', 8).toString('hex');
    if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {
        throw Error('Invalid signature hash length');
    }
    return utils_1.txidFromData(Buffer.from(sigHash, 'hex'));
}
exports.makeSigHashPreSign = makeSigHashPreSign;
function makeSigHashPostSign(curSigHash, pubKeyEncoding, signature) {
    // new hash combines the previous hash and all the new data this signature will add.  This
    // includes:
    // * the public key compression flag
    // * the signature
    const hashLength = 32 + 1 + constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;
    const sigHash = curSigHash + utils_1.leftPadHex(pubKeyEncoding.toString(16)) + signature.data;
    if (Buffer.from(sigHash, 'hex').byteLength > hashLength) {
        throw Error('Invalid signature hash length');
    }
    return utils_1.txidFromData(Buffer.from(sigHash, 'hex'));
}
function nextSignature(curSigHash, authType, fee, nonce, privateKey) {
    const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);
    const signature = keys_1.signWithKey(privateKey, sigHashPreSign);
    const publicKey = keys_1.getPublicKey(privateKey);
    const publicKeyEncoding = keys_1.isCompressed(publicKey)
        ? constants_1.PubKeyEncoding.Compressed
        : constants_1.PubKeyEncoding.Uncompressed;
    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKeyEncoding, signature);
    return {
        nextSig: signature,
        nextSigHash,
    };
}
exports.nextSignature = nextSignature;
function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {
    const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);
    const publicKey = keys_1.createStacksPublicKey(keys_1.publicKeyFromSignature(sigHashPreSign, signature));
    const nextSigHash = makeSigHashPostSign(sigHashPreSign, constants_1.PubKeyEncoding.Compressed, signature);
    return {
        pubKey: publicKey,
        nextSigHash,
    };
}
exports.nextVerification = nextVerification;
function newInitialSigHash() {
    const spendingCondition = createSingleSigSpendingCondition(constants_1.AddressHashMode.SerializeP2PKH, '', new BigNum(0), new BigNum(0));
    spendingCondition.signer = types_1.createEmptyAddress().hash160;
    spendingCondition.keyEncoding = constants_1.PubKeyEncoding.Compressed;
    spendingCondition.signature = emptyMessageSignature();
    return spendingCondition;
}
function verify(condition, initialSigHash, authType) {
    if (isSingleSig(condition)) {
        return verifySingleSig(condition, initialSigHash, authType);
    }
    else {
        // TODO: verify multisig
        return '';
    }
}
function verifySingleSig(condition, initialSigHash, authType) {
    const { pubKey, nextSigHash } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);
    // TODO: verify pub key
    return nextSigHash;
}
class Authorization extends Deserializable {
    constructor(authType, spendingConditions, sponsorSpendingCondition) {
        super();
        this.authType = authType;
        this.spendingCondition = spendingConditions;
        this.sponsorSpendingCondition = sponsorSpendingCondition;
    }
    intoInitialSighashAuth() {
        if (this.spendingCondition) {
            switch (this.authType) {
                case constants_1.AuthType.Standard:
                    return new Authorization(constants_1.AuthType.Standard, clearCondition(this.spendingCondition));
                case constants_1.AuthType.Sponsored:
                    return new Authorization(constants_1.AuthType.Sponsored, clearCondition(this.spendingCondition), newInitialSigHash());
                default:
                    throw new errors_1.SigningError('Unexpected authorization type for signing');
            }
        }
        throw new Error('Authorization missing SpendingCondition');
    }
    setFee(amount) {
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                this.spendingCondition.fee = amount;
                break;
            case constants_1.AuthType.Sponsored:
                this.sponsorSpendingCondition.fee = amount;
                break;
        }
    }
    getFee() {
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                return this.spendingCondition.fee;
            case constants_1.AuthType.Sponsored:
                return this.sponsorSpendingCondition.fee;
        }
    }
    setNonce(nonce) {
        this.spendingCondition.nonce = nonce;
    }
    setSponsorNonce(nonce) {
        this.sponsorSpendingCondition.nonce = nonce;
    }
    setSponsor(sponsorSpendingCondition) {
        this.sponsorSpendingCondition = sponsorSpendingCondition;
    }
    verifyOrigin(initialSigHash) {
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                return verify(this.spendingCondition, initialSigHash, constants_1.AuthType.Standard);
            case constants_1.AuthType.Sponsored:
                return verify(this.spendingCondition, initialSigHash, constants_1.AuthType.Standard);
            default:
                throw new errors_1.SigningError('Invalid origin auth type');
        }
    }
    serialize() {
        const bufferArray = new utils_1.BufferArray();
        if (this.authType === undefined) {
            throw new errors_1.SerializationError('"authType" is undefined');
        }
        bufferArray.appendByte(this.authType);
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                if (this.spendingCondition === undefined) {
                    throw new errors_1.SerializationError('"spendingCondition" is undefined');
                }
                bufferArray.push(serializeSpendingCondition(this.spendingCondition));
                break;
            case constants_1.AuthType.Sponsored:
                if (this.spendingCondition === undefined) {
                    throw new errors_1.SerializationError('"spendingCondition" is undefined');
                }
                if (this.sponsorSpendingCondition === undefined) {
                    throw new errors_1.SerializationError('"spendingCondition" is undefined');
                }
                bufferArray.push(serializeSpendingCondition(this.spendingCondition));
                bufferArray.push(serializeSpendingCondition(this.sponsorSpendingCondition));
                break;
            default:
                throw new errors_1.SerializationError(`Unexpected transaction AuthType while serializing: ${JSON.stringify(this.authType)}`);
        }
        return bufferArray.concatBuffer();
    }
    deserialize(bufferReader) {
        this.authType = bufferReader.readUInt8Enum(constants_1.AuthType, n => {
            throw new errors_1.DeserializationError(`Could not parse ${n} as AuthType`);
        });
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                this.spendingCondition = deserializeSpendingCondition(bufferReader);
                break;
            case constants_1.AuthType.Sponsored:
                this.spendingCondition = deserializeSpendingCondition(bufferReader);
                this.sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);
                break;
            // throw new DeserializationError('Not yet implemented: deserializing sponsored transactions');
            default:
                throw new errors_1.DeserializationError(`Unexpected transaction AuthType while deserializing: ${JSON.stringify(this.authType)}`);
        }
    }
}
exports.Authorization = Authorization;
class StandardAuthorization extends Authorization {
    constructor(spendingCondition) {
        super(constants_1.AuthType.Standard, spendingCondition);
    }
}
exports.StandardAuthorization = StandardAuthorization;
class SponsoredAuthorization extends Authorization {
    constructor(originSpendingCondition, sponsorSpendingCondition) {
        let sponsorSC = sponsorSpendingCondition;
        if (!sponsorSC) {
            sponsorSC = createSingleSigSpendingCondition(constants_1.AddressHashMode.SerializeP2PKH, '0'.repeat(66), new BigNum(0), new BigNum(0));
        }
        super(constants_1.AuthType.Sponsored, originSpendingCondition, sponsorSC);
    }
}
exports.SponsoredAuthorization = SponsoredAuthorization;
//# sourceMappingURL=authorization.js.map