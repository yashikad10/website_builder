"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionSigner = void 0;
const authorization_1 = require("./authorization");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
class TransactionSigner {
    constructor(transaction) {
        this.transaction = transaction;
        this.sigHash = transaction.signBegin();
        this.originDone = false;
        this.checkOversign = true;
        this.checkOverlap = true;
    }
    static createSponsorSigner(transaction, spendingCondition) {
        if (transaction.auth.authType != constants_1.AuthType.Sponsored) {
            throw new errors_1.SigningError('Cannot add sponsor to non-sponsored transaction');
        }
        const tx = utils_1.cloneDeep(transaction);
        tx.setSponsor(spendingCondition);
        const originSigHash = tx.verifyOrigin();
        const signer = new this(tx);
        signer.originDone = true;
        signer.sigHash = originSigHash;
        signer.checkOversign = true;
        signer.checkOverlap = true;
        return signer;
    }
    signOrigin(privateKey) {
        if (this.checkOverlap && this.originDone) {
            throw new errors_1.SigningError('Cannot sign origin after sponsor key');
        }
        if (this.transaction.auth === undefined) {
            throw new errors_1.SigningError('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.spendingCondition === undefined) {
            throw new errors_1.SigningError('"transaction.auth.spendingCondition" is undefined');
        }
        if (!authorization_1.isSingleSig(this.transaction.auth.spendingCondition)) {
            const spendingCondition = this.transaction.auth.spendingCondition;
            if (this.checkOversign &&
                spendingCondition.fields.length >= spendingCondition.signaturesRequired) {
                throw new Error('Origin would have too many signatures');
            }
        }
        const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);
        this.sigHash = nextSighash;
    }
    appendOrigin(publicKey) {
        if (this.checkOverlap && this.originDone) {
            throw Error('Cannot append public key to origin after sponsor key');
        }
        if (this.transaction.auth === undefined) {
            throw new Error('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.spendingCondition === undefined) {
            throw new Error('"transaction.auth.spendingCondition" is undefined');
        }
        this.transaction.appendPubkey(publicKey);
    }
    signSponsor(privateKey) {
        if (this.transaction.auth === undefined) {
            throw new errors_1.SigningError('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.sponsorSpendingCondition === undefined) {
            throw new errors_1.SigningError('"transaction.auth.spendingCondition" is undefined');
        }
        const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);
        this.sigHash = nextSighash;
        this.originDone = true;
    }
    getTxInComplete() {
        return utils_1.cloneDeep(this.transaction);
    }
    resume(transaction) {
        this.transaction = utils_1.cloneDeep(transaction);
        this.sigHash = transaction.signBegin();
    }
}
exports.TransactionSigner = TransactionSigner;
//# sourceMappingURL=signer.js.map