"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sponsorTransaction = exports.callReadOnlyFunction = exports.makeContractNonFungiblePostCondition = exports.makeStandardNonFungiblePostCondition = exports.makeContractFungiblePostCondition = exports.makeStandardFungiblePostCondition = exports.makeContractSTXPostCondition = exports.makeStandardSTXPostCondition = exports.makeContractCall = exports.estimateContractFunctionCall = exports.makeContractDeploy = exports.estimateContractDeploy = exports.makeSTXTokenTransfer = exports.makeUnsignedSTXTokenTransfer = exports.getAbi = exports.broadcastRawTransaction = exports.broadcastTransaction = exports.estimateTransfer = exports.getNonce = void 0;
const transaction_1 = require("./transaction");
const network_1 = require("./network");
const payload_1 = require("./payload");
const authorization_1 = require("./authorization");
const keys_1 = require("./keys");
const signer_1 = require("./signer");
const postcondition_1 = require("./postcondition");
const constants_1 = require("./constants");
const types_1 = require("./types");
const utils_1 = require("./utils");
const BigNum = require("bn.js");
const contract_abi_1 = require("./contract-abi");
const c32check_1 = require("c32check");
/**
 * Lookup the nonce for an address from a core node
 *
 * @param {string} address - the c32check address to look up
 * @param {StacksNetwork} network - the Stacks network to look up address on
 *
 * @return a promise that resolves to an integer
 */
function getNonce(address, network) {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultNetwork = new network_1.StacksMainnet();
        const url = network
            ? network.getAccountApiUrl(address)
            : defaultNetwork.getAccountApiUrl(address);
        const response = yield utils_1.fetchPrivate(url);
        if (!response.ok) {
            let msg = '';
            try {
                msg = yield response.text();
            }
            catch (error) { }
            throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
        }
        const result = (yield response.json());
        return new BigNum(result.nonce);
    });
}
exports.getNonce = getNonce;
/**
 * Estimate the total transaction fee in microstacks for a token transfer
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for
 * @param {StacksNetwork} network - the Stacks network to estimate transaction for
 *
 * @return a promise that resolves to number of microstacks per byte
 */
function estimateTransfer(transaction, network) {
    return __awaiter(this, void 0, void 0, function* () {
        if (transaction.payload.payloadType !== constants_1.PayloadType.TokenTransfer) {
            throw new Error(`Transaction fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.TokenTransfer]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
        }
        const requestHeaders = {
            Accept: 'application/text',
        };
        const fetchOptions = {
            method: 'GET',
            headers: requestHeaders,
        };
        const defaultNetwork = new network_1.StacksMainnet();
        const url = network
            ? network.getTransferFeeEstimateApiUrl()
            : defaultNetwork.getTransferFeeEstimateApiUrl();
        const response = yield utils_1.fetchPrivate(url, fetchOptions);
        if (!response.ok) {
            let msg = '';
            try {
                msg = yield response.text();
            }
            catch (error) { }
            throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
        }
        const feeRateResult = yield response.text();
        const txBytes = new BigNum(transaction.serialize().byteLength);
        const feeRate = new BigNum(feeRateResult);
        return feeRate.mul(txBytes);
    });
}
exports.estimateTransfer = estimateTransfer;
/**
 * Broadcast the signed transaction to a core node
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to broadcast
 * @param {StacksNetwork} network - the Stacks network to broadcast transaction to
 *
 * @returns {Promise} that resolves to a response if the operation succeeds
 */
function broadcastTransaction(transaction, network) {
    return __awaiter(this, void 0, void 0, function* () {
        const rawTx = transaction.serialize();
        const url = network.getBroadcastApiUrl();
        return broadcastRawTransaction(rawTx, url);
    });
}
exports.broadcastTransaction = broadcastTransaction;
/**
 * Broadcast the signed transaction to a core node
 *
 * @param {Buffer} rawTx - the raw serialized transaction buffer to broadcast
 * @param {string} url - the broadcast endpoint URL
 *
 * @returns {Promise} that resolves to a response if the operation succeeds
 */
function broadcastRawTransaction(rawTx, url) {
    return __awaiter(this, void 0, void 0, function* () {
        const requestHeaders = {
            'Content-Type': 'application/octet-stream',
        };
        const options = {
            method: 'POST',
            headers: requestHeaders,
            body: rawTx,
        };
        const response = yield utils_1.fetchPrivate(url, options);
        if (!response.ok) {
            try {
                return (yield response.json());
            }
            catch (e) {
                throw Error(`Failed to broadcast transaction: ${e.message}`);
            }
        }
        try {
            return (yield response.clone().json());
        }
        catch (e) {
            return yield response.clone().text();
        }
    });
}
exports.broadcastRawTransaction = broadcastRawTransaction;
/**
 * Fetch a contract's ABI
 *
 * @param {string} address - the contracts address
 * @param {string} contractName - the contracts name
 * @param {StacksNetwork} network - the Stacks network to broadcast transaction to
 *
 * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds
 */
function getAbi(address, contractName, network) {
    return __awaiter(this, void 0, void 0, function* () {
        const options = {
            method: 'GET',
        };
        const url = network.getAbiApiUrl(address, contractName);
        const response = yield utils_1.fetchPrivate(url, options);
        if (!response.ok) {
            let msg = '';
            try {
                msg = yield response.text();
            }
            catch (error) { }
            throw new Error(`Error fetching contract ABI for contract "${contractName}" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
        }
        return JSON.parse(yield response.text());
    });
}
exports.getAbi = getAbi;
/**
 * Generates an unsigned Stacks token transfer transaction
 *
 * Returns a Stacks token transfer transaction.
 *
 * @param  {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer
 *
 * @return {StacksTransaction}
 */
function makeUnsignedSTXTokenTransfer(txOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultOptions = {
            fee: new BigNum(0),
            nonce: new BigNum(0),
            network: new network_1.StacksMainnet(),
            anchorMode: constants_1.AnchorMode.Any,
            postConditionMode: constants_1.PostConditionMode.Deny,
            memo: '',
            sponsored: false,
        };
        const options = Object.assign(defaultOptions, txOptions);
        const payload = payload_1.createTokenTransferPayload(options.recipient, options.amount, options.memo);
        let authorization = null;
        let spendingCondition = null;
        if ('publicKey' in options) {
            // single-sig
            spendingCondition = authorization_1.createSingleSigSpendingCondition(constants_1.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
        }
        else {
            // multi-sig
            spendingCondition = authorization_1.createMultiSigSpendingCondition(constants_1.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
        }
        if (options.sponsored) {
            authorization = new authorization_1.SponsoredAuthorization(spendingCondition);
        }
        else {
            authorization = new authorization_1.StandardAuthorization(spendingCondition);
        }
        const postConditions = [];
        if (options.postConditions && options.postConditions.length > 0) {
            options.postConditions.forEach(postCondition => {
                postConditions.push(postCondition);
            });
        }
        const lpPostConditions = types_1.createLPList(postConditions);
        const transaction = new transaction_1.StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, defaultOptions.anchorMode, options.network.chainId);
        if (!txOptions.fee) {
            const txFee = yield estimateTransfer(transaction, options.network);
            transaction.setFee(txFee);
        }
        if (!txOptions.nonce) {
            const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
                ? constants_1.AddressVersion.MainnetSingleSig
                : constants_1.AddressVersion.TestnetSingleSig;
            const senderAddress = c32check_1.c32address(addressVersion, transaction.auth.spendingCondition.signer);
            const txNonce = yield getNonce(senderAddress, options.network);
            transaction.setNonce(txNonce);
        }
        return transaction;
    });
}
exports.makeUnsignedSTXTokenTransfer = makeUnsignedSTXTokenTransfer;
/**
 * Generates a signed Stacks token transfer transaction
 *
 * Returns a signed Stacks token transfer transaction.
 *
 * @param  {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer
 *
 * @return {StacksTransaction}
 */
function makeSTXTokenTransfer(txOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        if ('senderKey' in txOptions) {
            const publicKey = keys_1.publicKeyToString(keys_1.getPublicKey(keys_1.createStacksPrivateKey(txOptions.senderKey)));
            const options = utils_1.omit(txOptions, 'senderKey');
            const transaction = yield makeUnsignedSTXTokenTransfer(Object.assign({ publicKey }, options));
            const privKey = keys_1.createStacksPrivateKey(txOptions.senderKey);
            const signer = new signer_1.TransactionSigner(transaction);
            signer.signOrigin(privKey);
            return transaction;
        }
        else {
            const options = utils_1.omit(txOptions, 'signerKeys');
            const transaction = yield makeUnsignedSTXTokenTransfer(options);
            const signer = new signer_1.TransactionSigner(transaction);
            let pubKeys = txOptions.publicKeys;
            for (const key of txOptions.signerKeys) {
                const pubKey = keys_1.pubKeyfromPrivKey(key);
                pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));
                signer.signOrigin(keys_1.createStacksPrivateKey(key));
            }
            for (const key of pubKeys) {
                signer.appendOrigin(keys_1.publicKeyFromBuffer(Buffer.from(key, 'hex')));
            }
            return transaction;
        }
    });
}
exports.makeSTXTokenTransfer = makeSTXTokenTransfer;
/**
 * Estimate the total transaction fee in microstacks for a contract deploy
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for
 * @param {StacksNetwork} network - the Stacks network to estimate transaction for
 *
 * @return a promise that resolves to number of microstacks per byte
 */
function estimateContractDeploy(transaction, network) {
    return __awaiter(this, void 0, void 0, function* () {
        if (transaction.payload.payloadType !== constants_1.PayloadType.SmartContract) {
            throw new Error(`Contract deploy fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.SmartContract]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
        }
        const requestHeaders = {
            Accept: 'application/text',
        };
        const fetchOptions = {
            method: 'GET',
            headers: requestHeaders,
        };
        // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks
        // blockchain core
        const defaultNetwork = new network_1.StacksMainnet();
        const url = network
            ? network.getTransferFeeEstimateApiUrl()
            : defaultNetwork.getTransferFeeEstimateApiUrl();
        const response = yield utils_1.fetchPrivate(url, fetchOptions);
        if (!response.ok) {
            let msg = '';
            try {
                msg = yield response.text();
            }
            catch (error) { }
            throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
        }
        const feeRateResult = yield response.text();
        const txBytes = new BigNum(transaction.serialize().byteLength);
        const feeRate = new BigNum(feeRateResult);
        return feeRate.mul(txBytes);
    });
}
exports.estimateContractDeploy = estimateContractDeploy;
/**
 * Generates a Clarity smart contract deploy transaction
 *
 * @param  {ContractDeployOptions} txOptions - an options object for the contract deploy
 *
 * Returns a signed Stacks smart contract deploy transaction.
 *
 * @return {StacksTransaction}
 */
function makeContractDeploy(txOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultOptions = {
            fee: new BigNum(0),
            nonce: new BigNum(0),
            network: new network_1.StacksMainnet(),
            anchorMode: constants_1.AnchorMode.Any,
            postConditionMode: constants_1.PostConditionMode.Deny,
            sponsored: false,
        };
        const options = Object.assign(defaultOptions, txOptions);
        const payload = payload_1.createSmartContractPayload(options.contractName, options.codeBody);
        const addressHashMode = constants_1.AddressHashMode.SerializeP2PKH;
        const privKey = keys_1.createStacksPrivateKey(options.senderKey);
        const pubKey = keys_1.getPublicKey(privKey);
        let authorization = null;
        const spendingCondition = authorization_1.createSingleSigSpendingCondition(addressHashMode, keys_1.publicKeyToString(pubKey), options.nonce, options.fee);
        if (options.sponsored) {
            authorization = new authorization_1.SponsoredAuthorization(spendingCondition);
        }
        else {
            authorization = new authorization_1.StandardAuthorization(spendingCondition);
        }
        const postConditions = [];
        if (options.postConditions && options.postConditions.length > 0) {
            options.postConditions.forEach(postCondition => {
                postConditions.push(postCondition);
            });
        }
        const lpPostConditions = types_1.createLPList(postConditions);
        const transaction = new transaction_1.StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);
        if (!txOptions.fee) {
            const txFee = yield estimateContractDeploy(transaction, options.network);
            transaction.setFee(txFee);
        }
        if (!txOptions.nonce) {
            const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
                ? constants_1.AddressVersion.MainnetSingleSig
                : constants_1.AddressVersion.TestnetSingleSig;
            const senderAddress = keys_1.publicKeyToAddress(addressVersion, pubKey);
            const txNonce = yield getNonce(senderAddress, options.network);
            transaction.setNonce(txNonce);
        }
        if (options.senderKey) {
            const signer = new signer_1.TransactionSigner(transaction);
            signer.signOrigin(privKey);
        }
        return transaction;
    });
}
exports.makeContractDeploy = makeContractDeploy;
/**
 * Estimate the total transaction fee in microstacks for a contract function call
 *
 * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for
 * @param {StacksNetwork} network - the Stacks network to estimate transaction for
 *
 * @return a promise that resolves to number of microstacks per byte
 */
function estimateContractFunctionCall(transaction, network) {
    return __awaiter(this, void 0, void 0, function* () {
        if (transaction.payload.payloadType !== constants_1.PayloadType.ContractCall) {
            throw new Error(`Contract call fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.ContractCall]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
        }
        const requestHeaders = {
            Accept: 'application/text',
        };
        const fetchOptions = {
            method: 'GET',
            headers: requestHeaders,
        };
        // Place holder estimate until contract call fee estimation is fully implemented on Stacks
        // blockchain core
        const defaultNetwork = new network_1.StacksMainnet();
        const url = network
            ? network.getTransferFeeEstimateApiUrl()
            : defaultNetwork.getTransferFeeEstimateApiUrl();
        const response = yield utils_1.fetchPrivate(url, fetchOptions);
        if (!response.ok) {
            let msg = '';
            try {
                msg = yield response.text();
            }
            catch (error) { }
            throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
        }
        const feeRateResult = yield response.text();
        const txBytes = new BigNum(transaction.serialize().byteLength);
        const feeRate = new BigNum(feeRateResult);
        return feeRate.mul(txBytes);
    });
}
exports.estimateContractFunctionCall = estimateContractFunctionCall;
/**
 * Generates a Clarity smart contract function call transaction
 *
 * @param  {ContractCallOptions} txOptions - an options object for the contract function call
 *
 * Returns a signed Stacks smart contract function call transaction.
 *
 * @return {StacksTransaction}
 */
function makeContractCall(txOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultOptions = {
            fee: new BigNum(0),
            nonce: new BigNum(0),
            network: new network_1.StacksMainnet(),
            anchorMode: constants_1.AnchorMode.Any,
            postConditionMode: constants_1.PostConditionMode.Deny,
            sponsored: false,
        };
        const options = Object.assign(defaultOptions, txOptions);
        const payload = payload_1.createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);
        if (options === null || options === void 0 ? void 0 : options.validateWithAbi) {
            let abi;
            if (typeof options.validateWithAbi === 'boolean') {
                if (options === null || options === void 0 ? void 0 : options.network) {
                    abi = yield getAbi(options.contractAddress, options.contractName, options.network);
                }
                else {
                    throw new Error('Network option must be provided in order to validate with ABI');
                }
            }
            else {
                abi = options.validateWithAbi;
            }
            contract_abi_1.validateContractCall(payload, abi);
        }
        const addressHashMode = constants_1.AddressHashMode.SerializeP2PKH;
        const privKey = keys_1.createStacksPrivateKey(options.senderKey);
        const pubKey = keys_1.getPublicKey(privKey);
        let authorization = null;
        const spendingCondition = authorization_1.createSingleSigSpendingCondition(addressHashMode, keys_1.publicKeyToString(pubKey), options.nonce, options.fee);
        if (options.sponsored) {
            authorization = new authorization_1.SponsoredAuthorization(spendingCondition);
        }
        else {
            authorization = new authorization_1.StandardAuthorization(spendingCondition);
        }
        const postConditions = [];
        if (options.postConditions && options.postConditions.length > 0) {
            options.postConditions.forEach(postCondition => {
                postConditions.push(postCondition);
            });
        }
        const lpPostConditions = types_1.createLPList(postConditions);
        const transaction = new transaction_1.StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);
        if (!txOptions.fee) {
            const txFee = yield estimateContractFunctionCall(transaction, options.network);
            transaction.setFee(txFee);
        }
        if (!txOptions.nonce) {
            const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
                ? constants_1.AddressVersion.MainnetSingleSig
                : constants_1.AddressVersion.TestnetSingleSig;
            const senderAddress = keys_1.publicKeyToAddress(addressVersion, pubKey);
            const txNonce = yield getNonce(senderAddress, options.network);
            transaction.setNonce(txNonce);
        }
        if (options.senderKey) {
            const signer = new signer_1.TransactionSigner(transaction);
            signer.signOrigin(privKey);
        }
        return transaction;
    });
}
exports.makeContractCall = makeContractCall;
/**
 * Generates a STX post condition with a standard principal
 *
 * Returns a STX post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of STX tokens
 *
 * @return {STXPostCondition}
 */
function makeStandardSTXPostCondition(address, conditionCode, amount) {
    return postcondition_1.createSTXPostCondition(types_1.createStandardPrincipal(address), conditionCode, amount);
}
exports.makeStandardSTXPostCondition = makeStandardSTXPostCondition;
/**
 * Generates a STX post condition with a contract principal
 *
 * Returns a STX post condition object
 *
 * @param  {String} address - the c32check address of the contract
 * @param  {String} contractName - the name of the contract
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of STX tokens
 *
 * @return {STXPostCondition}
 */
function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {
    return postcondition_1.createSTXPostCondition(types_1.createContractPrincipal(address, contractName), conditionCode, amount);
}
exports.makeContractSTXPostCondition = makeContractSTXPostCondition;
/**
 * Generates a fungible token post condition with a standard principal
 *
 * Returns a fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of fungible tokens
 * @param  {AssetInfo} assetInfo - asset info describing the fungible token
 *
 * @return {FungiblePostCondition}
 */
function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {
    return postcondition_1.createFungiblePostCondition(types_1.createStandardPrincipal(address), conditionCode, amount, assetInfo);
}
exports.makeStandardFungiblePostCondition = makeStandardFungiblePostCondition;
/**
 * Generates a fungible token post condition with a contract principal
 *
 * Returns a fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {String} contractName - the name of the contract
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of fungible tokens
 * @param  {AssetInfo} assetInfo - asset info describing the fungible token
 *
 * @return {FungiblePostCondition}
 */
function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {
    return postcondition_1.createFungiblePostCondition(types_1.createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);
}
exports.makeContractFungiblePostCondition = makeContractFungiblePostCondition;
/**
 * Generates a non-fungible token post condition with a standard principal
 *
 * Returns a non-fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token
 * @param  {ClarityValue} assetName - asset name describing the non-fungible token
 *
 * @return {NonFungiblePostCondition}
 */
function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {
    return postcondition_1.createNonFungiblePostCondition(types_1.createStandardPrincipal(address), conditionCode, assetInfo, assetName);
}
exports.makeStandardNonFungiblePostCondition = makeStandardNonFungiblePostCondition;
/**
 * Generates a non-fungible token post condition with a contract principal
 *
 * Returns a non-fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {String} contractName - the name of the contract
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token
 * @param  {ClarityValue} assetName - asset name describing the non-fungible token
 *
 * @return {NonFungiblePostCondition}
 */
function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {
    return postcondition_1.createNonFungiblePostCondition(types_1.createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);
}
exports.makeContractNonFungiblePostCondition = makeContractNonFungiblePostCondition;
/**
 * Calls a read only function from a contract interface
 *
 * @param  {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object
 *
 * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.
 *
 * @return {ClarityValue}
 */
function callReadOnlyFunction(readOnlyFunctionOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultOptions = {
            network: new network_1.StacksMainnet(),
        };
        const options = Object.assign(defaultOptions, readOnlyFunctionOptions);
        const { contractName, contractAddress, functionName, functionArgs, network, senderAddress, } = options;
        const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);
        const args = functionArgs.map(arg => utils_1.cvToHex(arg));
        const body = JSON.stringify({
            sender: senderAddress,
            arguments: args,
        });
        const response = yield utils_1.fetchPrivate(url, {
            method: 'POST',
            body,
            headers: {
                'Content-Type': 'application/json',
            },
        });
        if (!response.ok) {
            let msg = '';
            try {
                msg = yield response.text();
            }
            catch (error) { }
            throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
        }
        return response.json().then(responseJson => utils_1.parseReadOnlyResponse(responseJson));
    });
}
exports.callReadOnlyFunction = callReadOnlyFunction;
/**
 * Constructs and signs a sponsored transaction as the sponsor
 *
 * @param  {SponsorOptions} sponsorOptions - the sponsor options object
 *
 * Returns a signed sponsored transaction.
 *
 * @return {ClarityValue}
 */
function sponsorTransaction(sponsorOptions) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const defaultOptions = {
            fee: new BigNum(0),
            sponsorNonce: new BigNum(0),
            sponsorAddressHashmode: constants_1.AddressHashMode.SerializeP2PKH,
        };
        const options = Object.assign(defaultOptions, sponsorOptions);
        const network = (_a = sponsorOptions.network) !== null && _a !== void 0 ? _a : (options.transaction.version === constants_1.TransactionVersion.Mainnet
            ? new network_1.StacksMainnet()
            : new network_1.StacksTestnet());
        const sponsorPubKey = keys_1.pubKeyfromPrivKey(options.sponsorPrivateKey);
        if (!sponsorOptions.fee) {
            let txFee = new BigNum(0);
            switch (options.transaction.payload.payloadType) {
                case constants_1.PayloadType.TokenTransfer:
                    txFee = yield estimateTransfer(options.transaction, network);
                    break;
                case constants_1.PayloadType.SmartContract:
                    txFee = yield estimateContractDeploy(options.transaction, network);
                    break;
                case constants_1.PayloadType.ContractCall:
                    txFee = yield estimateContractFunctionCall(options.transaction, network);
                    break;
                default:
                    throw new Error(`Spnsored transactions not supported for transaction type ${constants_1.PayloadType[options.transaction.payload.payloadType]}`);
            }
            options.transaction.setFee(txFee);
            options.fee = txFee;
        }
        if (!sponsorOptions.sponsorNonce) {
            const addressVersion = network.version === constants_1.TransactionVersion.Mainnet
                ? constants_1.AddressVersion.MainnetSingleSig
                : constants_1.AddressVersion.TestnetSingleSig;
            const senderAddress = keys_1.publicKeyToAddress(addressVersion, sponsorPubKey);
            const sponsorNonce = yield getNonce(senderAddress, network);
            options.sponsorNonce = sponsorNonce;
        }
        const sponsorSpendingCondition = authorization_1.createSingleSigSpendingCondition(options.sponsorAddressHashmode, keys_1.publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);
        options.transaction.setSponsor(sponsorSpendingCondition);
        const privKey = keys_1.createStacksPrivateKey(options.sponsorPrivateKey);
        const signer = signer_1.TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);
        signer.signSponsor(privKey);
        return options.transaction;
    });
}
exports.sponsorTransaction = sponsorTransaction;
//# sourceMappingURL=builders.js.map