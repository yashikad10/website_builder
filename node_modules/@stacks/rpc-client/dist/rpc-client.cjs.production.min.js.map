{"version":3,"file":"rpc-client.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import BN from 'bn.js';\nimport { serializeCV, ClarityValue } from '@blockstack/stacks-transactions';\nimport { TransactionResults } from '@blockstack/stacks-blockchain-sidecar-types';\nimport fetch from 'cross-fetch';\n\nexport interface Account {\n  balance: BN;\n  nonce: number;\n}\n\nexport const toBN = (hex: string) => {\n  return new BN(hex.slice(2), 16);\n};\n\ninterface FetchContractInterface {\n  contractAddress: string;\n  contractName: string;\n}\n\ninterface BufferArg {\n  buffer: {\n    length: number;\n  };\n}\n\nexport interface ContractInterfaceFunctionArg {\n  name: string;\n  type: string | BufferArg;\n}\n\nexport interface ContractInterfaceFunction {\n  name: string;\n  access: 'public' | 'private' | 'read_only';\n  args: ContractInterfaceFunctionArg[];\n}\n\nexport interface ContractInterface {\n  functions: ContractInterfaceFunction[];\n}\ninterface CallReadOnly extends FetchContractInterface {\n  args: ClarityValue[];\n  functionName: string;\n}\n\nexport class RPCClient {\n  url: string;\n\n  /**\n   * @param url The base URL for the RPC server\n   */\n  constructor(url: string) {\n    this.url = url;\n  }\n\n  async fetchAccount(principal: string): Promise<Account> {\n    const url = `${this.url}/v2/accounts/${principal}`;\n    const response = await fetch(url, {\n      credentials: 'omit',\n    });\n    const data = await response.json();\n    return {\n      balance: toBN(data.balance),\n      nonce: data.nonce,\n    };\n  }\n\n  async broadcastTX(hex: Buffer) {\n    const url = `${this.url}/v2/transactions`;\n    const response = await fetch(url, {\n      method: 'POST',\n      credentials: 'omit',\n      headers: {\n        'Content-Type': 'application/octet-stream',\n      },\n      body: hex,\n    });\n    return response;\n  }\n\n  async fetchContractInterface({\n    contractAddress,\n    contractName,\n  }: FetchContractInterface) {\n    const url = `${this.url}/v2/contracts/interface/${contractAddress}/${contractName}`;\n    const response = await fetch(url);\n    const contractInterface: ContractInterface = await response.json();\n    return contractInterface;\n  }\n\n  async callReadOnly({\n    contractName,\n    contractAddress,\n    functionName,\n    args,\n  }: CallReadOnly) {\n    const url = `${this.url}/v2/contracts/call-read/${contractAddress}/${contractName}/${functionName}`;\n    const argsStrings = args.map((arg) => {\n      return `0x${serializeCV(arg).toString('hex')}`;\n    });\n    const body = {\n      sender: 'SP31DA6FTSJX2WGTZ69SFY11BH51NZMB0ZW97B5P0',\n      arguments: argsStrings,\n    };\n    console.log(body);\n    const response = await fetch(url, {\n      method: 'POST',\n      body: JSON.stringify(body),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n    if (!response.ok) {\n      throw new Error(`Unable to call read-only function.`);\n    }\n    const data = await response.json();\n    console.log(data);\n    return data;\n  }\n\n  async fetchContractSource({\n    contractName,\n    contractAddress,\n  }: {\n    contractName: string;\n    contractAddress: string;\n  }) {\n    const url = `${this.url}/v2/contracts/source/${contractAddress}/${contractName}`;\n    const res = await fetch(url);\n    if (res.ok) {\n      const { source }: { source: string } = await res.json();\n      return source;\n    }\n    return null;\n  }\n\n  async fetchAddressTransactions({ address }: { address: string }) {\n    const url = `${this.url}/extended/v1/address/${address}/transactions`;\n    const res = await fetch(url);\n    const data: TransactionResults = await res.json();\n    return data.results;\n  }\n}\n\nexport default RPCClient;\n"],"names":["toBN","hex","BN","slice","RPCClient","url","fetchAccount","principal","fetch","this","credentials","response","json","data","balance","nonce","broadcastTX","method","headers","body","fetchContractInterface","contractAddress","contractName","callReadOnly","functionName","args","sender","map","arg","serializeCV","toString","console","log","JSON","stringify","ok","Error","fetchContractSource","res","source","fetchAddressTransactions","address","results"],"mappings":"6OAUaA,EAAO,SAACC,UACZ,IAAIC,EAAGD,EAAIE,MAAM,GAAI,KAiCjBC,wBAMCC,QACLA,IAAMA,6BAGPC,sBAAaC,8BAEMC,EADRC,KAAKJ,oBAAmBE,EACL,CAChCG,YAAa,yBADTC,0BAGaA,EAASC,uBAAtBC,SACC,CACLC,QAASd,EAAKa,EAAKC,SACnBC,MAAOF,EAAKE,mDAIVC,qBAAYf,8BAEOO,EADRC,KAAKJ,uBACc,CAChCY,OAAQ,OACRP,YAAa,OACbQ,QAAS,gBACS,4BAElBC,KAAMlB,2CAKJmB,uCACJC,IAAAA,gBACAC,IAAAA,wCAGuBd,EADRC,KAAKJ,+BAA8BgB,MAAmBC,mBAC/DX,0BAC6CA,EAASC,iDAIxDW,6BACJD,IAAAA,aACAD,IAAAA,gBACAG,IAAAA,aACAC,IAAAA,aAEMpB,EAASI,KAAKJ,+BAA8BgB,MAAmBC,MAAgBE,EAI/EL,EAAO,CACXO,OAAQ,wDAJUD,EAAKE,KAAI,SAACC,cAChBC,cAAYD,GAAKE,SAAS,kBAMxCC,QAAQC,IAAIb,mBACWX,EAAMH,EAAK,CAChCY,OAAQ,OACRE,KAAMc,KAAKC,UAAUf,GACrBD,QAAS,gBACS,sCAJdP,OAODA,EAASwB,SACN,IAAIC,mEAEOzB,EAASC,uBAAtBC,UACNkB,QAAQC,IAAInB,GACLA,8CAGHwB,oCACJf,IAAAA,aACAD,IAAAA,2CAMkBb,EADHC,KAAKJ,4BAA2BgB,MAAmBC,mBAC5DgB,4BACFA,EAAIH,0BACuCG,EAAI1B,wCAAzC2B,6DAGH,YAAA,8CAGHC,yCAA2BC,IAAAA,mCAEbjC,EADHC,KAAKJ,4BAA2BoC,mCACzCH,0BACiCA,EAAI1B,uBAArCC,UACCA,EAAK6B"}