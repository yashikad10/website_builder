import {
  __esm,
  __glob
} from "./chunk-AXPVERYL.js";

// node_modules/@stacks/connect-ui/dist/esm/session-9db1cb8a.js
var getRegisteredProviders, getInstalledProviders, getProviderFromId, LOCAL_STORAGE_KEY, getSelectedProviderId, setSelectedProviderId, clearSelectedProviderId;
var init_session_9db1cb8a = __esm({
  "node_modules/@stacks/connect-ui/dist/esm/session-9db1cb8a.js"() {
    getRegisteredProviders = () => {
      if (typeof window === "undefined")
        return [];
      if (!window.webbtc_stx_providers)
        return [];
      return window.webbtc_stx_providers;
    };
    getInstalledProviders = (defaultProviders = []) => {
      if (typeof window === "undefined")
        return [];
      const registeredProviders = getRegisteredProviders();
      const additionalInstalledProviders = defaultProviders.filter((defaultProvider) => {
        if (registeredProviders.find((rp) => rp.id === defaultProvider.id))
          return false;
        const provider = getProviderFromId(defaultProvider.id);
        return !!provider;
      });
      return registeredProviders.concat(additionalInstalledProviders);
    };
    getProviderFromId = (id) => {
      return id === null || id === void 0 ? void 0 : id.split(".").reduce((acc, part) => acc === null || acc === void 0 ? void 0 : acc[part], window);
    };
    LOCAL_STORAGE_KEY = "STX_PROVIDER";
    getSelectedProviderId = () => {
      if (typeof window === "undefined")
        return null;
      return window.localStorage.getItem(LOCAL_STORAGE_KEY);
    };
    setSelectedProviderId = (provider) => {
      if (typeof window !== "undefined") {
        window.localStorage.setItem(LOCAL_STORAGE_KEY, provider);
      }
    };
    clearSelectedProviderId = () => {
      if (typeof window !== "undefined") {
        window.localStorage.removeItem(LOCAL_STORAGE_KEY);
      }
    };
  }
});

// import("./**/*.entry.js") in node_modules/@stacks/connect-ui/dist/esm/index-f9076013.js
var globImport_entry_js;
var init_ = __esm({
  'import("./**/*.entry.js") in node_modules/@stacks/connect-ui/dist/esm/index-f9076013.js'() {
    globImport_entry_js = __glob({
      "./connect-modal.entry.js": () => import("./connect-modal.entry-5SFTGSML.js")
    });
  }
});

// node_modules/@stacks/connect-ui/dist/esm/index-f9076013.js
function queryNonceMetaTagContent(doc2) {
  var _a, _b, _c;
  return (_c = (_b = (_a = doc2.head) === null || _a === void 0 ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute("content")) !== null && _c !== void 0 ? _c : void 0;
}
var NAMESPACE, scopeId, hostTagName, isSvgMode, queuePending, createTime, uniqueTime, HYDRATED_CSS, EMPTY_OBJ, SVG_NS, HTML_NS, isDef, isComplexType, h, newVNode, Host, isHost, parsePropertyValue, getElement, emitEvent, rootAppliedStyles, registerStyle, addStyle, attachStyles, getScopeId, setAccessor, parseClassListRegex, parseClassList, updateElement, createElm, addVnodes, removeVnodes, updateChildren, isSameVnode, patch, renderVdom, attachToAncestor, scheduleUpdate, dispatchHooks, updateComponent, callRender, postUpdateComponent, appDidLoad, then, addHydratedFlag, getValue, setValue, proxyComponent, initializeComponent, connectedCallback, disconnectedCallback, bootstrapLazy, hostRefs, getHostRef, registerInstance, registerHost, isMemberInElement, consoleError, cmpModules, loadModule, styles, win, doc, plt, promiseResolve, supportsConstructableStylesheets, queueDomReads, queueDomWrites, queueTask, consume, flush, nextTick, writeTask;
var init_index_f9076013 = __esm({
  "node_modules/@stacks/connect-ui/dist/esm/index-f9076013.js"() {
    /* @vite-ignore */
    /* webpackInclude: /\.entry\.js$/ */
    /* webpackExclude: /\.system\.entry\.js$/ */
    /* webpackMode: "lazy" */
    init_();
    NAMESPACE = "connect-ui";
    isSvgMode = false;
    queuePending = false;
    createTime = (fnName, tagName = "") => {
      {
        return () => {
          return;
        };
      }
    };
    uniqueTime = (key, measureText) => {
      {
        return () => {
          return;
        };
      }
    };
    HYDRATED_CSS = "{visibility:hidden}.hydrated{visibility:inherit}";
    EMPTY_OBJ = {};
    SVG_NS = "http://www.w3.org/2000/svg";
    HTML_NS = "http://www.w3.org/1999/xhtml";
    isDef = (v) => v != null;
    isComplexType = (o) => {
      o = typeof o;
      return o === "object" || o === "function";
    };
    h = (nodeName, vnodeData, ...children) => {
      let child = null;
      let simple = false;
      let lastSimple = false;
      const vNodeChildren = [];
      const walk = (c) => {
        for (let i = 0; i < c.length; i++) {
          child = c[i];
          if (Array.isArray(child)) {
            walk(child);
          } else if (child != null && typeof child !== "boolean") {
            if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
              child = String(child);
            }
            if (simple && lastSimple) {
              vNodeChildren[vNodeChildren.length - 1].$text$ += child;
            } else {
              vNodeChildren.push(simple ? newVNode(null, child) : child);
            }
            lastSimple = simple;
          }
        }
      };
      walk(children);
      if (vnodeData) {
        {
          const classData = vnodeData.className || vnodeData.class;
          if (classData) {
            vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k) => classData[k]).join(" ");
          }
        }
      }
      const vnode = newVNode(nodeName, null);
      vnode.$attrs$ = vnodeData;
      if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
      }
      return vnode;
    };
    newVNode = (tag, text) => {
      const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null
      };
      {
        vnode.$attrs$ = null;
      }
      return vnode;
    };
    Host = {};
    isHost = (node) => node && node.$tag$ === Host;
    parsePropertyValue = (propValue, propType) => {
      if (propValue != null && !isComplexType(propValue)) {
        if (propType & 4) {
          return propValue === "false" ? false : propValue === "" || !!propValue;
        }
        return propValue;
      }
      return propValue;
    };
    getElement = (ref) => getHostRef(ref).$hostElement$;
    emitEvent = (elm, name, opts) => {
      const ev = plt.ce(name, opts);
      elm.dispatchEvent(ev);
      return ev;
    };
    rootAppliedStyles = /* @__PURE__ */ new WeakMap();
    registerStyle = (scopeId2, cssText, allowCS) => {
      let style = styles.get(scopeId2);
      if (supportsConstructableStylesheets && allowCS) {
        style = style || new CSSStyleSheet();
        if (typeof style === "string") {
          style = cssText;
        } else {
          style.replaceSync(cssText);
        }
      } else {
        style = cssText;
      }
      styles.set(scopeId2, style);
    };
    addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {
      var _a;
      let scopeId2 = getScopeId(cmpMeta);
      const style = styles.get(scopeId2);
      styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc;
      if (style) {
        if (typeof style === "string") {
          styleContainerNode = styleContainerNode.head || styleContainerNode;
          let appliedStyles = rootAppliedStyles.get(styleContainerNode);
          let styleElm;
          if (!appliedStyles) {
            rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
          }
          if (!appliedStyles.has(scopeId2)) {
            {
              {
                styleElm = doc.createElement("style");
                styleElm.innerHTML = style;
              }
              const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
              if (nonce != null) {
                styleElm.setAttribute("nonce", nonce);
              }
              styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
            }
            if (appliedStyles) {
              appliedStyles.add(scopeId2);
            }
          }
        } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
          styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
        }
      }
      return scopeId2;
    };
    attachStyles = (hostRef) => {
      const cmpMeta = hostRef.$cmpMeta$;
      const elm = hostRef.$hostElement$;
      const flags = cmpMeta.$flags$;
      const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
      const scopeId2 = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);
      if (flags & 10) {
        elm["s-sc"] = scopeId2;
        elm.classList.add(scopeId2 + "-h");
      }
      endAttachStyles();
    };
    getScopeId = (cmp, mode) => "sc-" + cmp.$tagName$;
    setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
      if (oldValue !== newValue) {
        let isProp = isMemberInElement(elm, memberName);
        let ln = memberName.toLowerCase();
        if (memberName === "class") {
          const classList = elm.classList;
          const oldClasses = parseClassList(oldValue);
          const newClasses = parseClassList(newValue);
          classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
          classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
        } else if (!isProp && memberName[0] === "o" && memberName[1] === "n") {
          if (memberName[2] === "-") {
            memberName = memberName.slice(3);
          } else if (isMemberInElement(win, ln)) {
            memberName = ln.slice(2);
          } else {
            memberName = ln[2] + memberName.slice(3);
          }
          if (oldValue) {
            plt.rel(elm, memberName, oldValue, false);
          }
          if (newValue) {
            plt.ael(elm, memberName, newValue, false);
          }
        } else {
          const isComplex = isComplexType(newValue);
          if ((isProp || isComplex && newValue !== null) && !isSvg) {
            try {
              if (!elm.tagName.includes("-")) {
                const n = newValue == null ? "" : newValue;
                if (memberName === "list") {
                  isProp = false;
                } else if (oldValue == null || elm[memberName] != n) {
                  elm[memberName] = n;
                }
              } else {
                elm[memberName] = newValue;
              }
            } catch (e) {
            }
          }
          if (newValue == null || newValue === false) {
            if (newValue !== false || elm.getAttribute(memberName) === "") {
              {
                elm.removeAttribute(memberName);
              }
            }
          } else if ((!isProp || flags & 4 || isSvg) && !isComplex) {
            newValue = newValue === true ? "" : newValue;
            {
              elm.setAttribute(memberName, newValue);
            }
          }
        }
      }
    };
    parseClassListRegex = /\s/;
    parseClassList = (value) => !value ? [] : value.split(parseClassListRegex);
    updateElement = (oldVnode, newVnode, isSvgMode2, memberName) => {
      const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
      const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
      const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
      {
        for (memberName in oldVnodeAttrs) {
          if (!(memberName in newVnodeAttrs)) {
            setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
          }
        }
      }
      for (memberName in newVnodeAttrs) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
      }
    };
    createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
      const newVNode2 = newParentVNode.$children$[childIndex];
      let i = 0;
      let elm;
      let childNode;
      if (newVNode2.$text$ !== null) {
        elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
      } else {
        if (!isSvgMode) {
          isSvgMode = newVNode2.$tag$ === "svg";
        }
        elm = newVNode2.$elm$ = doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode2.$tag$);
        if (isSvgMode && newVNode2.$tag$ === "foreignObject") {
          isSvgMode = false;
        }
        {
          updateElement(null, newVNode2, isSvgMode);
        }
        if (isDef(scopeId) && elm["s-si"] !== scopeId) {
          elm.classList.add(elm["s-si"] = scopeId);
        }
        if (newVNode2.$children$) {
          for (i = 0; i < newVNode2.$children$.length; ++i) {
            childNode = createElm(oldParentVNode, newVNode2, i);
            if (childNode) {
              elm.appendChild(childNode);
            }
          }
        }
        {
          if (newVNode2.$tag$ === "svg") {
            isSvgMode = false;
          } else if (elm.tagName === "foreignObject") {
            isSvgMode = true;
          }
        }
      }
      return elm;
    };
    addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
      let containerElm = parentElm;
      let childNode;
      if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
      }
      for (; startIdx <= endIdx; ++startIdx) {
        if (vnodes[startIdx]) {
          childNode = createElm(null, parentVNode, startIdx);
          if (childNode) {
            vnodes[startIdx].$elm$ = childNode;
            containerElm.insertBefore(childNode, before);
          }
        }
      }
    };
    removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {
      for (; startIdx <= endIdx; ++startIdx) {
        if (vnode = vnodes[startIdx]) {
          elm = vnode.$elm$;
          elm.remove();
        }
      }
    };
    updateChildren = (parentElm, oldCh, newVNode2, newCh) => {
      let oldStartIdx = 0;
      let newStartIdx = 0;
      let oldEndIdx = oldCh.length - 1;
      let oldStartVnode = oldCh[0];
      let oldEndVnode = oldCh[oldEndIdx];
      let newEndIdx = newCh.length - 1;
      let newStartVnode = newCh[0];
      let newEndVnode = newCh[newEndIdx];
      let node;
      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (oldStartVnode == null) {
          oldStartVnode = oldCh[++oldStartIdx];
        } else if (oldEndVnode == null) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (newStartVnode == null) {
          newStartVnode = newCh[++newStartIdx];
        } else if (newEndVnode == null) {
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newStartVnode)) {
          patch(oldStartVnode, newStartVnode);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (isSameVnode(oldEndVnode, newEndVnode)) {
          patch(oldEndVnode, newEndVnode);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newEndVnode)) {
          patch(oldStartVnode, newEndVnode);
          parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldEndVnode, newStartVnode)) {
          patch(oldEndVnode, newStartVnode);
          parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          {
            node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);
            newStartVnode = newCh[++newStartIdx];
          }
          if (node) {
            {
              oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
            }
          }
        }
      }
      if (oldStartIdx > oldEndIdx) {
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
      }
    };
    isSameVnode = (leftVNode, rightVNode) => {
      if (leftVNode.$tag$ === rightVNode.$tag$) {
        return true;
      }
      return false;
    };
    patch = (oldVNode, newVNode2) => {
      const elm = newVNode2.$elm$ = oldVNode.$elm$;
      const oldChildren = oldVNode.$children$;
      const newChildren = newVNode2.$children$;
      const tag = newVNode2.$tag$;
      const text = newVNode2.$text$;
      if (text === null) {
        {
          isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
        }
        {
          {
            updateElement(oldVNode, newVNode2, isSvgMode);
          }
        }
        if (oldChildren !== null && newChildren !== null) {
          updateChildren(elm, oldChildren, newVNode2, newChildren);
        } else if (newChildren !== null) {
          if (oldVNode.$text$ !== null) {
            elm.textContent = "";
          }
          addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
        } else if (oldChildren !== null) {
          removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
        if (isSvgMode && tag === "svg") {
          isSvgMode = false;
        }
      } else if (oldVNode.$text$ !== text) {
        elm.data = text;
      }
    };
    renderVdom = (hostRef, renderFnResults) => {
      const hostElm = hostRef.$hostElement$;
      const oldVNode = hostRef.$vnode$ || newVNode(null, null);
      const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
      hostTagName = hostElm.tagName;
      rootVnode.$tag$ = null;
      rootVnode.$flags$ |= 4;
      hostRef.$vnode$ = rootVnode;
      rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
      {
        scopeId = hostElm["s-sc"];
      }
      patch(oldVNode, rootVnode);
    };
    attachToAncestor = (hostRef, ancestorComponent) => {
      if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
        ancestorComponent["s-p"].push(new Promise((r) => hostRef.$onRenderResolve$ = r));
      }
    };
    scheduleUpdate = (hostRef, isInitialLoad) => {
      {
        hostRef.$flags$ |= 16;
      }
      if (hostRef.$flags$ & 4) {
        hostRef.$flags$ |= 512;
        return;
      }
      attachToAncestor(hostRef, hostRef.$ancestorComponent$);
      const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
      return writeTask(dispatch);
    };
    dispatchHooks = (hostRef, isInitialLoad) => {
      const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
      const instance = hostRef.$lazyInstance$;
      let promise;
      endSchedule();
      return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));
    };
    updateComponent = async (hostRef, instance, isInitialLoad) => {
      const elm = hostRef.$hostElement$;
      const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
      const rc = elm["s-rc"];
      if (isInitialLoad) {
        attachStyles(hostRef);
      }
      const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
      {
        callRender(hostRef, instance);
      }
      if (rc) {
        rc.map((cb) => cb());
        elm["s-rc"] = void 0;
      }
      endRender();
      endUpdate();
      {
        const childrenPromises = elm["s-p"];
        const postUpdate = () => postUpdateComponent(hostRef);
        if (childrenPromises.length === 0) {
          postUpdate();
        } else {
          Promise.all(childrenPromises).then(postUpdate);
          hostRef.$flags$ |= 4;
          childrenPromises.length = 0;
        }
      }
    };
    callRender = (hostRef, instance, elm) => {
      try {
        instance = instance.render();
        {
          hostRef.$flags$ &= ~16;
        }
        {
          hostRef.$flags$ |= 2;
        }
        {
          {
            {
              renderVdom(hostRef, instance);
            }
          }
        }
      } catch (e) {
        consoleError(e, hostRef.$hostElement$);
      }
      return null;
    };
    postUpdateComponent = (hostRef) => {
      const tagName = hostRef.$cmpMeta$.$tagName$;
      const elm = hostRef.$hostElement$;
      const endPostUpdate = createTime("postUpdate", tagName);
      const ancestorComponent = hostRef.$ancestorComponent$;
      if (!(hostRef.$flags$ & 64)) {
        hostRef.$flags$ |= 64;
        {
          addHydratedFlag(elm);
        }
        endPostUpdate();
        {
          hostRef.$onReadyResolve$(elm);
          if (!ancestorComponent) {
            appDidLoad();
          }
        }
      } else {
        endPostUpdate();
      }
      {
        if (hostRef.$onRenderResolve$) {
          hostRef.$onRenderResolve$();
          hostRef.$onRenderResolve$ = void 0;
        }
        if (hostRef.$flags$ & 512) {
          nextTick(() => scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= ~(4 | 512);
      }
    };
    appDidLoad = (who) => {
      {
        addHydratedFlag(doc.documentElement);
      }
      nextTick(() => emitEvent(win, "appload", { detail: { namespace: NAMESPACE } }));
    };
    then = (promise, thenFn) => {
      return promise && promise.then ? promise.then(thenFn) : thenFn();
    };
    addHydratedFlag = (elm) => elm.classList.add("hydrated");
    getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
    setValue = (ref, propName, newVal, cmpMeta) => {
      const hostRef = getHostRef(ref);
      const oldVal = hostRef.$instanceValues$.get(propName);
      const flags = hostRef.$flags$;
      const instance = hostRef.$lazyInstance$;
      newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
      const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
      const didValueChange = newVal !== oldVal && !areBothNaN;
      if ((!(flags & 8) || oldVal === void 0) && didValueChange) {
        hostRef.$instanceValues$.set(propName, newVal);
        if (instance) {
          if ((flags & (2 | 16)) === 2) {
            scheduleUpdate(hostRef, false);
          }
        }
      }
    };
    proxyComponent = (Cstr, cmpMeta, flags) => {
      if (cmpMeta.$members$) {
        const members = Object.entries(cmpMeta.$members$);
        const prototype = Cstr.prototype;
        members.map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 || flags & 2 && memberFlags & 32) {
            Object.defineProperty(prototype, memberName, {
              get() {
                return getValue(this, memberName);
              },
              set(newValue) {
                setValue(this, memberName, newValue, cmpMeta);
              },
              configurable: true,
              enumerable: true
            });
          }
        });
        if (flags & 1) {
          const attrNameToPropName = /* @__PURE__ */ new Map();
          prototype.attributeChangedCallback = function(attrName, _oldValue, newValue) {
            plt.jmp(() => {
              const propName = attrNameToPropName.get(attrName);
              if (this.hasOwnProperty(propName)) {
                newValue = this[propName];
                delete this[propName];
              } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && this[propName] == newValue) {
                return;
              }
              this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
            });
          };
          Cstr.observedAttributes = members.filter(
            ([_, m]) => m[0] & 15
            /* MEMBER_FLAGS.HasAttribute */
          ).map(([propName, m]) => {
            const attrName = m[1] || propName;
            attrNameToPropName.set(attrName, propName);
            return attrName;
          });
        }
      }
      return Cstr;
    };
    initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
      if ((hostRef.$flags$ & 32) === 0) {
        {
          hostRef.$flags$ |= 32;
          Cstr = loadModule(cmpMeta);
          if (Cstr.then) {
            const endLoad = uniqueTime();
            Cstr = await Cstr;
            endLoad();
          }
          if (!Cstr.isProxied) {
            proxyComponent(
              Cstr,
              cmpMeta,
              2
              /* PROXY_FLAGS.proxyState */
            );
            Cstr.isProxied = true;
          }
          const endNewInstance = createTime("createInstance", cmpMeta.$tagName$);
          {
            hostRef.$flags$ |= 8;
          }
          try {
            new Cstr(hostRef);
          } catch (e) {
            consoleError(e);
          }
          {
            hostRef.$flags$ &= ~8;
          }
          endNewInstance();
        }
        if (Cstr.style) {
          let style = Cstr.style;
          const scopeId2 = getScopeId(cmpMeta);
          if (!styles.has(scopeId2)) {
            const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
            registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
            endRegisterStyles();
          }
        }
      }
      const ancestorComponent = hostRef.$ancestorComponent$;
      const schedule = () => scheduleUpdate(hostRef, true);
      if (ancestorComponent && ancestorComponent["s-rc"]) {
        ancestorComponent["s-rc"].push(schedule);
      } else {
        schedule();
      }
    };
    connectedCallback = (elm) => {
      if ((plt.$flags$ & 1) === 0) {
        const hostRef = getHostRef(elm);
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
        if (!(hostRef.$flags$ & 1)) {
          hostRef.$flags$ |= 1;
          {
            let ancestorComponent = elm;
            while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
              if (ancestorComponent["s-p"]) {
                attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
                break;
              }
            }
          }
          if (cmpMeta.$members$) {
            Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
              if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
                const value = elm[memberName];
                delete elm[memberName];
                elm[memberName] = value;
              }
            });
          }
          {
            initializeComponent(elm, hostRef, cmpMeta);
          }
        }
        endConnected();
      }
    };
    disconnectedCallback = (elm) => {
      if ((plt.$flags$ & 1) === 0) {
        getHostRef(elm);
      }
    };
    bootstrapLazy = (lazyBundles, options = {}) => {
      var _a;
      const endBootstrap = createTime();
      const cmpTags = [];
      const exclude = options.exclude || [];
      const customElements = win.customElements;
      const head = doc.head;
      const metaCharset = head.querySelector("meta[charset]");
      const visibilityStyle = doc.createElement("style");
      const deferredConnectedCallbacks = [];
      let appLoadFallback;
      let isBootstrapping = true;
      Object.assign(plt, options);
      plt.$resourcesUrl$ = new URL(options.resourcesUrl || "./", doc.baseURI).href;
      lazyBundles.map((lazyBundle) => {
        lazyBundle[1].map((compactMeta) => {
          const cmpMeta = {
            $flags$: compactMeta[0],
            $tagName$: compactMeta[1],
            $members$: compactMeta[2],
            $listeners$: compactMeta[3]
          };
          {
            cmpMeta.$members$ = compactMeta[2];
          }
          const tagName = cmpMeta.$tagName$;
          const HostElement = class extends HTMLElement {
            // StencilLazyHost
            constructor(self) {
              super(self);
              self = this;
              registerHost(self, cmpMeta);
              if (cmpMeta.$flags$ & 1) {
                {
                  {
                    self.attachShadow({ mode: "open" });
                  }
                }
              }
            }
            connectedCallback() {
              if (appLoadFallback) {
                clearTimeout(appLoadFallback);
                appLoadFallback = null;
              }
              if (isBootstrapping) {
                deferredConnectedCallbacks.push(this);
              } else {
                plt.jmp(() => connectedCallback(this));
              }
            }
            disconnectedCallback() {
              plt.jmp(() => disconnectedCallback(this));
            }
            componentOnReady() {
              return getHostRef(this).$onReadyPromise$;
            }
          };
          cmpMeta.$lazyBundleId$ = lazyBundle[0];
          if (!exclude.includes(tagName) && !customElements.get(tagName)) {
            cmpTags.push(tagName);
            customElements.define(tagName, proxyComponent(
              HostElement,
              cmpMeta,
              1
              /* PROXY_FLAGS.isElementConstructor */
            ));
          }
        });
      });
      {
        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;
        visibilityStyle.setAttribute("data-styles", "");
        const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
        if (nonce != null) {
          visibilityStyle.setAttribute("nonce", nonce);
        }
        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);
      }
      isBootstrapping = false;
      if (deferredConnectedCallbacks.length) {
        deferredConnectedCallbacks.map((host) => host.connectedCallback());
      } else {
        {
          plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));
        }
      }
      endBootstrap();
    };
    hostRefs = /* @__PURE__ */ new WeakMap();
    getHostRef = (ref) => hostRefs.get(ref);
    registerInstance = (lazyInstance, hostRef) => hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);
    registerHost = (elm, cmpMeta) => {
      const hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $cmpMeta$: cmpMeta,
        $instanceValues$: /* @__PURE__ */ new Map()
      };
      {
        hostRef.$onReadyPromise$ = new Promise((r) => hostRef.$onReadyResolve$ = r);
        elm["s-p"] = [];
        elm["s-rc"] = [];
      }
      return hostRefs.set(elm, hostRef);
    };
    isMemberInElement = (elm, memberName) => memberName in elm;
    consoleError = (e, el) => (0, console.error)(e, el);
    cmpModules = /* @__PURE__ */ new Map();
    loadModule = (cmpMeta, hostRef, hmrVersionId) => {
      const exportName = cmpMeta.$tagName$.replace(/-/g, "_");
      const bundleId = cmpMeta.$lazyBundleId$;
      const module = cmpModules.get(bundleId);
      if (module) {
        return module[exportName];
      }
      if (!hmrVersionId || !BUILD.hotModuleReplacement) {
        const processMod = (importedModule) => {
          cmpModules.set(bundleId, importedModule);
          return importedModule[exportName];
        };
        switch (bundleId) {
          case "connect-modal":
            return import(
              /* webpackMode: "lazy" */
              "./connect-modal.entry-5SFTGSML.js"
            ).then(processMod, consoleError);
        }
      }
      return globImport_entry_js(`./${bundleId}.entry.js${""}`).then((importedModule) => {
        {
          cmpModules.set(bundleId, importedModule);
        }
        return importedModule[exportName];
      }, consoleError);
    };
    styles = /* @__PURE__ */ new Map();
    win = typeof window !== "undefined" ? window : {};
    doc = win.document || { head: {} };
    plt = {
      $flags$: 0,
      $resourcesUrl$: "",
      jmp: (h2) => h2(),
      raf: (h2) => requestAnimationFrame(h2),
      ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
      rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
      ce: (eventName, opts) => new CustomEvent(eventName, opts)
    };
    promiseResolve = (v) => Promise.resolve(v);
    supportsConstructableStylesheets = (() => {
      try {
        new CSSStyleSheet();
        return typeof new CSSStyleSheet().replaceSync === "function";
      } catch (e) {
      }
      return false;
    })();
    queueDomReads = [];
    queueDomWrites = [];
    queueTask = (queue, write) => (cb) => {
      queue.push(cb);
      if (!queuePending) {
        queuePending = true;
        if (write && plt.$flags$ & 4) {
          nextTick(flush);
        } else {
          plt.raf(flush);
        }
      }
    };
    consume = (queue) => {
      for (let i = 0; i < queue.length; i++) {
        try {
          queue[i](performance.now());
        } catch (e) {
          consoleError(e);
        }
      }
      queue.length = 0;
    };
    flush = () => {
      consume(queueDomReads);
      {
        consume(queueDomWrites);
        if (queuePending = queueDomReads.length > 0) {
          plt.raf(flush);
        }
      }
    };
    nextTick = (cb) => promiseResolve().then(cb);
    writeTask = queueTask(queueDomWrites, true);
  }
});

export {
  getInstalledProviders,
  getProviderFromId,
  getSelectedProviderId,
  setSelectedProviderId,
  clearSelectedProviderId,
  init_session_9db1cb8a,
  h,
  getElement,
  bootstrapLazy,
  registerInstance,
  promiseResolve,
  init_index_f9076013
};
//# sourceMappingURL=chunk-UL2OYPDW.js.map
